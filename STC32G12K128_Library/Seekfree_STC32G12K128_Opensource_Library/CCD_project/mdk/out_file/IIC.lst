C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN .\out_file\IIC.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\Hardware\IIC.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(SIZE) BRO
                    -WSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;.
                    -.\user;..\code;..\Hardware) DEBUG PRINT(.\out_file\IIC.lst) OBJECT(.\out_file\IIC.obj) 

stmt  level    source

    1          #include "IIC.h"
    2          #include "my_uart.h"
    3          
    4          u8 success = 1;  // 添加success变量定义
    5          u8 DisplayFlag=0;
    6          u8 display_index=0;
    7          u8 found=0;
    8          u8 addr=0;
    9          u16 Test_cnt=0;
   10          
   11          bit isda;                                       //设备地址标志
   12          bit isma;                                       //存储地址标志
   13          bit B_1ms;          //1ms标志
   14          
   15          sbit I2C_SDA = P0^5;    // 主机SDA - P0.5 (可用)
   16          sbit I2C_SCL = P0^4;    // 主机SCL - P0.4 (可用)
   17          
   18          // 从设备引脚也使用可用的引脚
   19          sbit I2C_SLAVE_SDA = P0^7;  // 从机SDA - P0.7 (可用)  
   20          sbit I2C_SLAVE_SCL = P0^6;  // 从机SCL - P0.6 (可用)
   21          // 添加函数声明
   22          // 正确定义地址
   23          #define SLAVE_ADDR_7BIT  0x30    // 7位从机地址
   24          #define SLAVE_ADDR_WRITE 0x60    // 8位写地址 (SLAVE_ADDR_7BIT << 1)
   25          #define SLAVE_ADDR_READ  0x61    // 8位读地址 (SLAVE_ADDR_7BIT << 1 | 0x01)
   26          
   27          // 保持向后兼容
   28          #define SLAW SLAVE_ADDR_WRITE
   29          #define SLAR SLAVE_ADDR_READ
   30          #define SLAVE_ADDR SLAVE_ADDR_7BIT  // 从机代码使用7位地址
   31          
   32          
   33          // 添加I2C测试数据
   34          u8 i2c_test_data[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
   35          u8 i2c_read_buffer[16] = {0};
   36          u8 i2c_slave_receive_buffer[16] = {0};  // 从设备接收缓冲区
   37          u8 slave_data_ready = 0;  // 从设备数据就绪标志
   38          u8 slave_receive_count = 0;
   39          
   40          void uart_send_hex_8bit(u8 dat);
   41          //void SendI2CDataToUart(u8 *data, u8 len);
   42          //void sendI2CStatusToUART(char *status);
   43          
   44          void uart_send_hex_8bit(unsigned char dat)
   45          {
   46   1          uint8 hex_chars[]="0123456789ABCDEF";
   47   1          uart_write_byte(UART_INDEX,hex_chars[dat<<4]);
   48   1          uart_write_byte(UART_INDEX,hex_chars[dat&0x0F]);
   49   1      }
   50          
   51          //IIC是开漏输出!!!
   52          void IIC_intit()
   53          {
   54   1          WTST = 0;
   55   1          EAXFR = 1;
   56   1          CKCON = 0;
   57   1      
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 2   

   58   1          // 只配置可用的P0.4-P0.7引脚为开漏模式
   59   1          // P0.4(SCL主机), P0.5(SDA主机), P0.6(SCL从机), P0.7(SDA从机)
   60   1          P0M1 = 0xF0;   // 1111 0000 - P0.4~P0.7设为开漏
   61   1          P0M0 = 0xF0;   // 1111 0000
   62   1          
   63   1          // 其他端口配置保持不变
   64   1          P1M1 = 0x30; P1M0 = 0x30;   
   65   1          P2M1 = 0x3c; P2M0 = 0x3c;   
   66   1          P3M1 = 0x50; P3M0 = 0x50;
   67   1          P4M1 = 0x3c; P4M0 = 0x3c;   
   68   1          P5M1 = 0x0c; P5M0 = 0x0c;   
   69   1          P6M1 = 0xff; P6M0 = 0xff;   
   70   1          P7M1 = 0x00; P7M0 = 0x00;
   71   1      
   72   1          I2CCFG = 0x00;
   73   1      
   74   1          display_index = 0;
   75   1          DisplayFlag = 0;
   76   1          isda = 1;
   77   1          isma = 1;
   78   1          addr = 0;
   79   1          
   80   1          // 初始化引脚
   81   1          I2C_SDA = 1;
   82   1          I2C_SCL = 1;
   83   1          I2C_SLAVE_SDA = 1;
   84   1          I2C_SLAVE_SCL = 1;
   85   1          
   86   1          EA = 1;
   87   1          gpio_set_level(LED1,0);
   88   1          printf("I2C Initialized - Using P0.4-P0.7 (P0.0-P0.3 are faulty)\r\n");
   89   1      }
   90          
   91          void I2C_Delay(void)
   92          {
   93   1          u16 dly = 20;
   94   1          while(--dly);
   95   1      }
   96          
   97          void I2C_Start(void)
   98          {
   99   1          I2C_SDA = 1;
  100   1          I2C_Delay();
  101   1          I2C_SCL = 1;
  102   1          I2C_Delay();
  103   1          I2C_SDA = 0;
  104   1          I2C_Delay();
  105   1          I2C_SCL = 0;
  106   1          I2C_Delay();
  107   1      }
  108          
  109          void I2C_Stop(void)
  110          {
  111   1          I2C_SDA = 0;
  112   1          I2C_Delay();
  113   1          I2C_SCL = 1;
  114   1          I2C_Delay();
  115   1          I2C_SDA = 1;
  116   1          I2C_Delay();
  117   1      }
  118          
  119          void I2C_SendACK(void)
  120          {
  121   1          I2C_SDA = 0;
  122   1          I2C_Delay();
  123   1          I2C_SCL = 1;
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 3   

  124   1          I2C_Delay();
  125   1          I2C_SCL = 0;
  126   1          I2C_Delay();
  127   1      }
  128          
  129          void I2C_SendNoACK(void)
  130          {
  131   1          I2C_SDA = 1;
  132   1          I2C_Delay();
  133   1          I2C_SCL = 1;
  134   1          I2C_Delay();
  135   1          I2C_SCL = 0;
  136   1          I2C_Delay();
  137   1      }
  138          
  139          bit I2C_CheckACK(void)
  140          {
  141   1          bit ack;
  142   1          
  143   1          I2C_SDA = 1;
  144   1          I2C_Delay();
  145   1          I2C_SCL = 1;
  146   1          I2C_Delay();
  147   1          ack = I2C_SDA;
  148   1          I2C_SCL = 0;
  149   1          I2C_Delay();
  150   1          
  151   1          return !ack;
  152   1      }
  153          
  154          bit I2C_SendByte(u8 dat)
  155          {
  156   1          u8 i;
  157   1          
  158   1          for(i = 0; i < 8; i++) {
  159   2              if(dat & 0x80) 
  160   2                  I2C_SDA = 1;
  161   2              else 
  162   2                  I2C_SDA = 0;
  163   2              dat <<= 1;
  164   2              I2C_Delay();
  165   2              I2C_SCL = 1;
  166   2              I2C_Delay();
  167   2              // 调试：打印每一位的状态
  168   2               printf("[Master] Sending bit %d: SDA=%d, SCL=%d\n", i, I2C_SDA, I2C_SCL);
  169   2              I2C_SCL = 0;
  170   2              I2C_Delay();
  171   2          }
  172   1          
  173   1          return I2C_CheckACK();
  174   1      }
  175          
  176          u8 I2C_RecvByte(bit ack)
  177          {
  178   1          u8 i, dat = 0;
  179   1          
  180   1          I2C_SDA = 1;
  181   1          
  182   1          for(i = 0; i < 8; i++) {
  183   2              I2C_SCL = 1;
  184   2              I2C_Delay();
  185   2              dat <<= 1;
  186   2              if(I2C_SDA) 
  187   2                  dat |= 0x01;
  188   2              I2C_SCL = 0;
  189   2              I2C_Delay();
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 4   

  190   2          }
  191   1          
  192   1          if(ack)
  193   1              I2C_SendACK();
  194   1          else
  195   1              I2C_SendNoACK();
  196   1              
  197   1          return dat;
  198   1      }
  199          
  200          void WriteNbyte(unsigned char addr, unsigned char *p, unsigned char number)   //typedef 问题
  201          {
  202   1          unsigned char local_success = 1;  // 使用局部变量
  203   1          unsigned char i=0;
  204   1          
  205   1          //printf("[DEBUG] Starting I2C write...\r\n");
  206   1          I2C_Start();
  207   1          //printf("[DEBUG] Start condition sent\r\n");
  208   1          
  209   1          if(!I2C_SendByte(SLAW)) {
  210   2              I2C_Stop();
  211   2               //printf("Write Failed - No ACK at device address\n\r");
  212   2              return;
  213   2          }
  214   1          
  215   1          if(!I2C_SendByte(addr)) {
  216   2              I2C_Stop();
  217   2                //printf("Write Failed - No ACK at register address\n\r");
  218   2              return;
  219   2          }
  220   1      
  221   1          //printf("Writing I2C: Addr=0x");
  222   1          uart_send_hex_8bit(addr);
  223   1          //printf(" Data=");
  224   1         
  225   1          for(i=0;i<number;i++)
  226   1          {
  227   2             if(!I2C_SendByte(*p)) {
  228   3                  local_success = 0;
  229   3                  break;
  230   3              }
  231   2              uart_send_hex_8bit(*p);
  232   2              uart_write_byte(UART_INDEX, ' ');
  233   2              p++;
  234   2          }
  235   1      
  236   1          I2C_Stop();
  237   1      
  238   1           if(local_success) {
  239   2              printf("- Write OK\r\n");
  240   2          } else {
  241   2              printf("- Write Failed\r\n");
  242   2          }
  243   1      }
  244          
  245          void ReadNbyte(u8 addr, u8 *p, u8 number)
  246          {
  247   1          u8 i=0;
  248   1          
  249   1          I2C_Start();
  250   1          if(!I2C_SendByte(SLAW)) {
  251   2              I2C_Stop();
  252   2              printf("Read Failed - No ACK at device address");
  253   2              return;
  254   2          }
  255   1          
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 5   

  256   1          if(!I2C_SendByte(addr)) {
  257   2              I2C_Stop();
  258   2               printf("Read Failed - No ACK at register address");
  259   2              return;
  260   2          }
  261   1          
  262   1          I2C_Start();
  263   1          if(!I2C_SendByte(SLAR)) {
  264   2              I2C_Stop();
  265   2              printf("Read Failed - No ACK at read command");
  266   2              return;
  267   2          }
  268   1          printf("Reading I2C: Addr=0x");
  269   1          uart_send_hex_8bit(addr);
  270   1          printf(" Data=");
  271   1      
  272   1          for(i = 0; i < number; i++) {
  273   2              *p = I2C_RecvByte(i != (number-1));
  274   2              uart_send_hex_8bit(*p);
  275   2              uart_write_byte(UART_INDEX, ' ');
  276   2              p++;
  277   2          }
  278   1          
  279   1          I2C_Stop();
  280   1          printf("- Read OK\r\n");
  281   1      }
  282          
  283          // 简化的起始条件检测 - 非阻塞
  284          int I2C_Slave_CheckStart(void)
  285          {
  286   1          static bit last_sda = 1;
  287   1          static bit last_scl = 1;
  288   1          
  289   1          bit current_sda = I2C_SLAVE_SDA;
  290   1          bit current_scl = I2C_SLAVE_SCL;
  291   1          
  292   1          // 检测起始条件：SCL高电平期间SDA从高到低
  293   1          if(last_scl && current_scl &&  // SCL保持高
  294   1             last_sda && !current_sda) { // SDA从高变低
  295   2              last_sda = current_sda;
  296   2              last_scl = current_scl;
  297   2              return 1;
  298   2          }
  299   1          
  300   1          last_sda = current_sda;
  301   1          last_scl = current_scl;
  302   1          return 0;
  303   1      }
  304          
  305          // 简化的停止条件检测 - 非阻塞
  306          int I2C_Slave_CheckStop(void)
  307          {
  308   1          static bit last_sda = 1;
  309   1          static bit last_scl = 1;
  310   1          
  311   1          bit current_sda = I2C_SLAVE_SDA;
  312   1          bit current_scl = I2C_SLAVE_SCL;
  313   1          
  314   1          // 检测停止条件：SCL高电平期间SDA从低到高
  315   1          if(last_scl && current_scl &&  // SCL保持高
  316   1             !last_sda && current_sda) { // SDA从低变高
  317   2              last_sda = current_sda;
  318   2              last_scl = current_scl;
  319   2              return 1;
  320   2          }
  321   1          
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 6   

  322   1          last_sda = current_sda;
  323   1          last_scl = current_scl;
  324   1          return 0;
  325   1      }
  326          bit I2C_Slave_ReceiveBit(u8 *byte, u8 bit_position)
  327          {
  328   1          static u32 last_check_time = 0;
  329   1          u32 current_time = pit_read(); // 需要实现获取系统时间
  330   1          
  331   1          // 避免过于频繁的检查
  332   1          if(current_time - last_check_time < 1) {
  333   2              return 0;
  334   2          }
  335   1          last_check_time = current_time;
  336   1          
  337   1          // 等待时钟变高
  338   1          if(I2C_SLAVE_SCL) {
  339   2              // 读取数据位
  340   2              if(I2C_SLAVE_SDA) {
  341   3                  *byte |= (1 << (7 - bit_position));
  342   3              }
  343   2              // 等待时钟变低
  344   2              while(I2C_SLAVE_SCL) {
  345   3                  // 空循环等待
  346   3              }
  347   2              return 1; // 成功接收一个bit
  348   2          }
  349   1          
  350   1          return 0; // 尚未接收到完整的bit
  351   1      }
  352          
  353          
  354          void I2C_Slave_SendACK(void)
  355          {
  356   1          // 设置SDA为低电平（ACK）
  357   1          I2C_SLAVE_SDA = 0;
  358   1          
  359   1          // 产生一个时钟脉冲
  360   1          I2C_SLAVE_SCL = 1;
  361   1          I2C_Delay();
  362   1          I2C_SLAVE_SCL = 0;
  363   1          I2C_Delay();
  364   1          
  365   1          // 释放SDA
  366   1          I2C_SLAVE_SDA = 1;
  367   1      }
  368          
  369          void I2C_Slave_Process(void)
  370          {
  371   1          static u8 debug_counter = 0;
  372   1          static unsigned char slave_state = 0;
  373   1          static unsigned char current_bit = 0;
  374   1          static unsigned char received_byte = 0;
  375   1          unsigned char i;
  376   1          unsigned long wait_start;
  377   1          unsigned long heartbeat_counter;
  378   1           u8 received_7bit_addr;
  379   1          static u8 address_byte = 0;
  380   1          static u8 is_write_operation = 0;
  381   1          static u8 send_byte = 0;
  382   1          static u8 send_data_index = 0;
  383   1          static u8 last_bit_count;
  384   1          
  385   1          // 大幅减少调试输出
  386   1          if(heartbeat_counter++ > 100) {
  387   2              heartbeat_counter = 0;
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 7   

  388   2              gpio_toggle_level(LED1);
  389   2          }
  390   1          
  391   1          if(debug_counter++ > 200) {
  392   2              debug_counter = 0;
  393   2              // uart_write_string(UART_INDEX,"[Slave] Active\r\n");
  394   2          }
  395   1          
  396   1          switch(slave_state) {
  397   2              case 0: // 等待起始条件
  398   2                  if(I2C_Slave_CheckStart()) {
  399   3                      slave_state = 1;
  400   3                      current_bit = 0;
  401   3                      received_byte = 0;
  402   3                      if(debug_counter > 50) {
  403   4                          debug_counter = 0;
  404   4                          uart_write_string(UART_INDEX,"[Slave] Start detected\r\n");
  405   4                      }         
  406   3                  }   
  407   2                  break;
  408   2                  
  409   2              case 1: // 接收地址字节
  410   2                  if(current_bit < 8) {
  411   3                      // 简化接收逻辑
  412   3                      if(I2C_SLAVE_SCL) {
  413   4                          received_byte = (received_byte << 1) | (I2C_SLAVE_SDA ? 1 : 0);
  414   4                          
  415   4                          last_bit_count = 0;
  416   4                          if(current_bit != last_bit_count) {
  417   5                              last_bit_count = current_bit;
  418   5                              printf("[Slave] Receiving bit %d, SDA=%d, current byte=0x%02X\r\n", 
  419   5                                     7 - current_bit, I2C_SLAVE_SDA, received_byte);
  420   5                          }
  421   4                          
  422   4                          current_bit++;
  423   4                          // 等待SCL变低，有超时保护
  424   4                          wait_start = pit_read();  // 在循环内部获取时间
  425   4                          while(I2C_SLAVE_SCL) {
  426   5                              if(pit_read() - wait_start > 10) { // 10ms超时
  427   6                                  slave_state = 0; // 超时复位
  428   6                                  break;
  429   6                              }
  430   5                          }  // 添加缺失的括号
  431   4                      }
  432   3                  } else {
  433   3                      // 检查地址匹配
  434   3                       received_7bit_addr = received_byte >> 1;
  435   3                      printf("[Slave] Received address: 0x%02X, Expected: 0x%02X\r\n", received_7bit_addr, SLAV
             -E_ADDR);
  436   3                      if((received_byte >> 1) == SLAVE_ADDR) {
  437   4                      I2C_Slave_SendACK();
  438   4                  
  439   4                      // 根据读写位决定进入接收模式还是发送模式
  440   4                      if(received_byte & 0x01) {
  441   5                      // 读操作 - 进入发送模式 (state = 3)
  442   5                      slave_state = 3;
  443   5                      current_bit = 0;
  444   5                      send_data_index = 0;
  445   5                      // 准备要发送的数据
  446   5                          if(slave_receive_count > 0) {
  447   6                              send_byte = i2c_slave_receive_buffer[0];
  448   6                          } else {
  449   6                              send_byte = 0xAA; // 默认测试数据
  450   6                          }
  451   5                      uart_write_string(UART_INDEX, "[Slave] Entering transmit mode\r\n");
  452   5                      printf("[Slave] Will send: 0x%02X\r\n", send_byte);
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 8   

  453   5                      } else {
  454   5                      // 写操作 - 进入接收模式 (state = 2)
  455   5                      slave_state = 2;
  456   5                      slave_receive_count = 0;
  457   5                      uart_write_string(UART_INDEX, "[Slave] Entering receive mode\r\n");
  458   5                      }
  459   4                  } else {
  460   4                      slave_state = 0; // 地址不匹配，回到等待
  461   4                  }
  462   3                  current_bit = 0;
  463   3              }
  464   2                  break;
  465   2                  
  466   2              case 2: // 接收数据
  467   2                  if(current_bit < 8) {
  468   3                      if(I2C_SLAVE_SCL) {
  469   4                          received_byte = (received_byte << 1) | (I2C_SLAVE_SDA ? 1 : 0);
  470   4                          current_bit++;
  471   4                          // 等待SCL变低，有超时保护
  472   4                          wait_start = pit_read();
  473   4                          while(I2C_SLAVE_SCL) {
  474   5                              if(pit_read() - wait_start > 10) { // 10ms超时
  475   6                                  slave_state = 0;
  476   6                                  break;
  477   6                              }
  478   5                          }  // 添加缺失的括号
  479   4                      }
  480   3                  } else {
  481   3                      // 存储数据
  482   3                      if(slave_receive_count < sizeof(i2c_slave_receive_buffer)) {
  483   4                          i2c_slave_receive_buffer[slave_receive_count++] = received_byte;
  484   4                      }
  485   3                      I2C_Slave_SendACK();
  486   3                      current_bit = 0;
  487   3                      received_byte = 0;
  488   3                  }
  489   2                  // 检查停止条件
  490   2                  if(I2C_Slave_CheckStop()) {
  491   3                      if(slave_receive_count > 0) {
  492   4                          slave_data_ready = 1;
  493   4                      }
  494   3                      slave_state = 0;
  495   3                      if(debug_counter > 25) {
  496   4                          uart_write_string(UART_INDEX,"[Slave] Stop detected\r\n");
  497   4                      }
  498   3                  }
  499   2                  break;
  500   2               case 3: // 发送数据模式（主机读取）
  501   2                  // 在SCL低电平时设置数据位
  502   2                  if(!I2C_SLAVE_SCL && current_bit < 8) {
  503   3                      // 设置当前数据位
  504   3                      u8 bit_value = (send_byte >> (7 - current_bit)) & 0x01;
  505   3                      I2C_SLAVE_SDA = bit_value;
  506   3                      current_bit++;
  507   3                       printf("[Slave Debug] After setting - SDA pin: %d\r\n", I2C_SLAVE_SDA);
  508   3                      // 调试输出
  509   3                      if(current_bit == 1) {
  510   4                          printf("[Slave] Starting to send byte: 0x%02X\r\n", send_byte);
  511   4                      }
  512   3                  }
  513   2                  
  514   2                  // 检查是否完成一个字节的发送
  515   2                  if(current_bit >= 8) {
  516   3                      // 等待主机提供第9个时钟（ACK位）
  517   3                      if(I2C_SLAVE_SCL) {
  518   4                          // 释放SDA，让主机发送ACK/NACK
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 9   

  519   4                          I2C_SLAVE_SDA = 1;
  520   4                          
  521   4                          // 短暂延时确保信号稳定
  522   4                          system_delay_ms(1);
  523   4                          
  524   4                          // 检查主机的ACK
  525   4                          if(!I2C_SLAVE_SDA) {
  526   5                              // 主机发送了ACK，准备下一个字节
  527   5                              send_data_index++;
  528   5                              current_bit = 0;
  529   5                              
  530   5                              // 准备下一个要发送的字节
  531   5                              if(send_data_index < slave_receive_count) {
  532   6                                  send_byte = i2c_slave_receive_buffer[send_data_index];
  533   6                              } else {
  534   6                                  // 发送测试数据
  535   6                                  send_byte = 0x50 + send_data_index;
  536   6                              }
  537   5                              
  538   5                              printf("[Slave] ACK received, next byte: 0x%02X\r\n", send_byte);
  539   5                          } else {
  540   5                              // 主机发送了NACK，停止发送
  541   5                              printf("[Slave] NACK received, stopping transmission\r\n");
  542   5                              slave_state = 0;
  543   5                          }
  544   4                      }
  545   3                  }
  546   2                  
  547   2                  // 检查停止条件
  548   2                  if(I2C_Slave_CheckStop()) {
  549   3                      printf("[Slave] Stop during transmission\r\n");
  550   3                      slave_state = 0;
  551   3                  }
  552   2                  break;    
  553   2                  
  554   2          }
  555   1      }
*** WARNING C47 IN LINE 375 OF ..\Hardware\IIC.c: 'i': unreferenced local variable
  556              
  557          void ScanI2CDevices(void)
  558          {
  559   1          u8 i;
  560   1      
  561   1          printf("Scanning I2C devices (0x08-0x77)...\r\n");
  562   1              for(addr = 0x08; addr <= 0x77; addr++) {
  563   2              I2C_Start();
  564   2              if(I2C_SendByte(addr << 1)) {
  565   3                  printf("Found device at: 0x");
  566   3                  uart_send_hex_8bit(addr);
  567   3                  printf("\r\n");
  568   3                  found++;
  569   3              }
  570   2              I2C_Stop();
  571   2             // 短暂延时，避免总线冲突
  572   2              for( i = 0; i < 50; i++);
  573   2          }
  574   1          if(!found) {
  575   2          printf("No I2C devices found!\r\n");
  576   2          } else {
  577   2              printf("Scan completed. Found ");
  578   2              uart_send_hex_8bit(found);
  579   2              printf(" device(s)\r\n");
  580   2          }
  581   1      }
  582          void I2C_AutoTestProcess(void)
  583          {
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 10  

  584   1          u32 msecound=pit_read();
  585   1          static u8 test_phase=0;
  586   1          static u32 last_test_time=0;
  587   1      
  588   1      //    if(msecound-last_test_time<3000){
  589   1      //        retrun; //每三秒执行一次测试
  590   1      //    }
  591   1      
  592   1          last_test_time=msecound;
  593   1          
  594   1          switch(test_phase){
  595   2              case 0:
  596   2                  // 阶段0：写入测试数据
  597   2                  printf("=== I2C Auto Test Phase 1: Writing Data ===\r\n");
  598   2                  WriteNbyte(0x00, i2c_test_data, sizeof(i2c_test_data));
  599   2                  break;
  600   2              case 1:
  601   2                  // 阶段1：读取验证数据
  602   2                  printf("=== I2C Auto Test Phase 2: Reading Data ===\r\n");
  603   2                  ReadNbyte(0x00, i2c_read_buffer, sizeof(i2c_test_data));
  604   2                  
  605   2                  // // 验证数据是否正确
  606   2                  // printf("Data Verification: ");
  607   2                  // u8 verify_ok = 1;
  608   2                  // for(u8 i = 0; i < sizeof(i2c_test_data); i++) {
  609   2                  //     if(i2c_read_buffer[i] != i2c_test_data[i]) {
  610   2                  //         verify_ok = 0;
  611   2                  //         break;
  612   2                  //     }
  613   2                  // }
  614   2                  // if(verify_ok) {
  615   2                  //     printf("PASS\r\n");
  616   2                  // } else {
  617   2                  //     printf("FAIL\r\n");
  618   2                  // }
  619   2      
  620   2                  break;
  621   2              case 2:
  622   2                  // 阶段2：扫描I2C设备
  623   2                  printf("=== I2C Auto Test Phase 3: Scanning Devices ===\r\n");
  624   2                  ScanI2CDevices();
  625   2                  break;
  626   2              }
  627   1           test_phase++;
  628   1          if(test_phase > 2) {
  629   2              test_phase = 0;
  630   2          }
  631   1      
  632   1      }
  633          
  634          uint32 msecond=0;
  635          // 修改IIC_Process函数，添加自动测试
  636          void IIC_Process(void)
  637          {
  638   1          u8 i=0;
  639   1      
  640   1          u8 tmp[4]={0};
  641   1          
  642   1          
  643   1      //    if(DisplayFlag)
  644   1      //    {
  645   1      //        DisplayFlag = 0;
  646   1      //    }
  647   1      //    
  648   1      //    // 处理I2C从设备通信
  649   1            I2C_Slave_Process();
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 11  

  650   1      
  651   1      //     // 如果从设备接收到数据，通过串口发送
  652   1      //    if(slave_data_ready) {
  653   1      //        printf("New Slave Data: ");
  654   1      //        for(i = 0; i < 8; i++) {
  655   1      //            uart_send_hex_8bit(i2c_slave_receive_buffer[i]);
  656   1      //            uart_write_byte(UART_INDEX, ' ');
  657   1      //        }
  658   1      //        printf("\r\n");
  659   1      //        slave_data_ready = 0;
  660   1      //    }
  661   1      //    
  662   1      
  663   1      //    if(pit_state)
  664   1      //    {
  665   1      //        pit_state = 0;
  666   1          
  667   1      //        if(msecond >= 1000)        //测试
  668   1      //        {
  669   1      //            msecond = 0;
  670   1                  Test_cnt++;
  671   1                  if(Test_cnt>10000) Test_cnt = 0;
  672   1      
  673   1                  tmp[0] = Test_cnt / 1000;
  674   1                  tmp[1] = (Test_cnt % 1000) / 100;
  675   1                  tmp[2] = (Test_cnt % 100) / 10;
  676   1                  tmp[3] = Test_cnt % 10;
  677   1                  gpio_toggle_level(LED1);
  678   1                  
  679   1                  // // 执行I2C写入操作，并通过串口发送结果
  680   1                  WriteNbyte(0, tmp, 4);
  681   1                  
  682   1      //        }
  683   1          //} 
  684   1      }
  685          void Test_I2C_Wiring(void)
  686          {
  687   1          uart_write_string(UART_INDEX, "=== Testing I2C Wiring ===\r\n");
  688   1          
  689   1          // 测试1：主机发送起始条件，从机应该能检测到
  690   1          uart_write_string(UART_INDEX, "Sending START condition...\r\n");
  691   1          I2C_Start();
  692   1          system_delay_ms(100);
  693   1          I2C_Stop();
  694   1          
  695   1          // 测试2：检查从机引脚状态
  696   1          uart_write_string(UART_INDEX, "Checking slave pin states:\r\n");
  697   1          printf("SLAVE_SCL: %d, SLAVE_SDA: %d\r\n", I2C_SLAVE_SCL, I2C_SLAVE_SDA);
  698   1          
  699   1          // 测试3：简单的数据发送测试
  700   1          uart_write_string(UART_INDEX, "Sending test byte...\r\n");
  701   1          I2C_Start();
  702   1          if(I2C_SendByte(0x30)) {
  703   2              uart_write_string(UART_INDEX, "ACK received - Wiring OK!\r\n");
  704   2          } else {
  705   2              uart_write_string(UART_INDEX, "NO ACK - Check wiring!\r\n");
  706   2          }
  707   1          I2C_Stop();
  708   1          
  709   1          uart_write_string(UART_INDEX, "=== Wiring Test Complete ===\r\n\r\n");
  710   1      }
  711          
  712          void Check_Pin_Configuration(void)
  713          {
  714   1          uart_write_string(UART_INDEX, "=== Pin Configuration Check ===\r\n");
  715   1          
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 12  

  716   1          // 检查主机引脚
  717   1          printf("MASTER - SDA(P0.1): %d, SCL(P0.0): %d\r\n", I2C_SDA, I2C_SCL);
  718   1          
  719   1          // 检查从机引脚  
  720   1          printf("SLAVE - SDA(P0.3): %d, SCL(P0.2): %d\r\n", I2C_SLAVE_SDA, I2C_SLAVE_SCL);
  721   1          
  722   1          // 测试引脚输出能力
  723   1          uart_write_string(UART_INDEX, "Testing pin output...\r\n");
  724   1          
  725   1          // 测试主机SDA
  726   1          I2C_SDA = 0; system_delay_ms(100);
  727   1          printf("Master SDA set to 0: %d\r\n", I2C_SDA);
  728   1          I2C_SDA = 1; system_delay_ms(100);
  729   1          printf("Master SDA set to 1: %d\r\n", I2C_SDA);
  730   1          
  731   1          // 测试从机SDA
  732   1          I2C_SLAVE_SDA = 0; system_delay_ms(100);
  733   1          printf("Slave SDA set to 0: %d\r\n", I2C_SLAVE_SDA);
  734   1          I2C_SLAVE_SDA = 1; system_delay_ms(100);
  735   1          printf("Slave SDA set to 1: %d\r\n", I2C_SLAVE_SDA);
  736   1          
  737   1          uart_write_string(UART_INDEX, "=== Pin Check Complete ===\r\n\r\n");
  738   1      }
  739          
  740          void I2C_Slave_Simple_Test(void)
  741          {
  742   1          static u32 last_print = 0;
  743   1         // 检测起始条件（简化版）
  744   1         static bit last_sda = 1, last_scl = 1;
  745   1         bit current_sda = I2C_SLAVE_SDA;
  746   1         bit current_scl = I2C_SLAVE_SCL;
  747   1          u32 current_time = pit_read();
  748   1          
  749   1          // 每500ms打印一次引脚状态
  750   1          if(current_time - last_print > 500) {
  751   2              last_print = current_time;
  752   2              
  753   2              printf("SLAVE PINS - SCL: %d, SDA: %d\r\n", 
  754   2                     I2C_SLAVE_SCL, I2C_SLAVE_SDA);
  755   2              
  756   2      
  757   2              
  758   2              // 检测起始条件
  759   2              if(last_scl && current_scl && last_sda && !current_sda) {
  760   3                  uart_write_string(UART_INDEX, "*** START Condition Detected! ***\r\n");
  761   3              }
  762   2              
  763   2              // 检测停止条件
  764   2              if(last_scl && current_scl && !last_sda && current_sda) {
  765   3                  uart_write_string(UART_INDEX, "*** STOP Condition Detected! ***\r\n");
  766   3              }
  767   2              
  768   2              last_sda = current_sda;
  769   2              last_scl = current_scl;
  770   2          }
  771   1      }
  772          void Test_Without_External_Pullup(void)
  773          {
  774   1          uart_write_string(UART_INDEX, "=== Testing with Internal Weak Pull-up ===\r\n");
  775   1          
  776   1          // 设置为准双向模式（使用内部弱上拉）
  777   1          P0M1 = 0x00;   // 所有P0口设为准双向
  778   1          P0M0 = 0x00;
  779   1          
  780   1          // 测试总线电平
  781   1          printf("Bus levels - SDA: %d, SCL: %d\r\n", I2C_SDA, I2C_SCL);
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 13  

  782   1          
  783   1          // 简单通信测试
  784   1          I2C_Start();
  785   1          if(I2C_SendByte(0x30)) {  // 从机地址 + 写位
  786   2              uart_write_string(UART_INDEX, "ACK with weak pull-up!\r\n");
  787   2          } else {
  788   2              uart_write_string(UART_INDEX, "No ACK even with weak pull-up\r\n");
  789   2          }
  790   1          I2C_Stop();
  791   1          
  792   1          // 恢复开漏模式
  793   1          P0M1 = 0x0F;
  794   1          P0M0 = 0x0F;
  795   1      }
  796          
  797          void Complete_I2C_Communication_Test(void)
  798          {
  799   1          u8 test_data[] = {0xAA, 0x55, 0x01, 0x02, 0x03};
  800   1          u8 read_buffer[5] = {0};
  801   1          int i;
  802   1          
  803   1          uart_write_string(UART_INDEX, "=== Complete I2C Communication Test ===\r\n");
  804   1          
  805   1          // 测试1：主机向从机写入数据
  806   1          printf("1. Master writing 5 bytes to slave...\r\n");
  807   1          I2C_Start();
  808   1          if(I2C_SendByte(0x60)) {  // 从机地址 + 写位
  809   2              uart_write_string(UART_INDEX, "   Address ACK received\r\n");
  810   2              
  811   2              // 发送数据
  812   2              for(i = 0; i < 5; i++) {
  813   3                  if(I2C_SendByte(test_data[i])) {
  814   4                      printf("   Data 0x%02X ACK received\r\n", test_data[i]);
  815   4                  } else {
  816   4                      printf("   Data 0x%02X NO ACK\r\n", test_data[i]);
  817   4                  }
  818   3              }
  819   2          } else {
  820   2              uart_write_string(UART_INDEX, "   Address NO ACK\r\n");
  821   2          }
  822   1          I2C_Stop();
  823   1          
  824   1          // 短暂延时让从机处理数据
  825   1          system_delay_ms(10);
  826   1          
  827   1          // 测试2：主机从从机读取数据
  828   1          printf("2. Master reading from slave...\r\n");
  829   1          I2C_Start();
  830   1          if(I2C_SendByte(0x61)) {  // 从机地址 + 读位
  831   2              uart_write_string(UART_INDEX, "   Read address ACK received\r\n");
  832   2              
  833   2              // 读取数据
  834   2              for(i = 0; i < 5; i++) {
  835   3                  read_buffer[i] = I2C_RecvByte(i != 4);  // 最后一个字节发送NACK
  836   3                  printf("   Read data 0x%02X\r\n", read_buffer[i]);
  837   3              }
  838   2          } else {
  839   2              uart_write_string(UART_INDEX, "   Read address NO ACK\r\n");
  840   2          }
  841   1          I2C_Stop();
  842   1          
  843   1          printf("=== Complete Test Finished ===\r\n\r\n");
  844   1      }
  845          
  846          void Enhanced_Complete_Test(void)
  847          {
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 14  

  848   1          u8 test_data[] = {0xAA, 0x55, 0x01, 0x02, 0x03};
  849   1          u8 read_buffer[8] = {0};
  850   1          u8 verify_ok = 1;
  851   1          int i;
  852   1          
  853   1          uart_write_string(UART_INDEX, "=== Enhanced Complete I2C Test ===\r\n");
  854   1          
  855   1          // 阶段1：主机向从机写入数据
  856   1          printf("1. MASTER WRITING 5 bytes to slave...\r\n");
  857   1          I2C_Start();
  858   1          if(I2C_SendByte(0x60)) {
  859   2              uart_write_string(UART_INDEX, "   Address ACK received\r\n");
  860   2              
  861   2              for(i = 0; i < 5; i++) {
  862   3                  if(I2C_SendByte(test_data[i])) {
  863   4                      printf("   Data 0x%02X ACK received\r\n", test_data[i]);
  864   4                  } else {
  865   4                      printf("   Data 0x%02X NO ACK\r\n", test_data[i]);
  866   4                  }
  867   3              }
  868   2          }
  869   1          I2C_Stop();
  870   1          
  871   1          // 等待从机处理数据
  872   1          system_delay_ms(50);
  873   1          
  874   1          // 阶段2：主机从从机读取数据
  875   1          printf("2. MASTER READING from slave...\r\n");
  876   1          I2C_Start();
  877   1          if(I2C_SendByte(0x61)) {
  878   2              uart_write_string(UART_INDEX, "   Read address ACK received\r\n");
  879   2              
  880   2              // 读取8个字节（从机应该返回之前写入的数据+测试数据）
  881   2              for( i = 0; i < 8; i++) {
  882   3                  read_buffer[i] = I2C_RecvByte(i != 7);  // 最后一个字节发送NACK
  883   3                  printf("   Read data[%d]: 0x%02X\r\n", i, read_buffer[i]);
  884   3              }
  885   2      //     read_buffer[0] = I2C_RecvByte(0); // 发送NACK，表示只读取一个字节
  886   2      //     printf("   Read data[0]: 0x%02X\r\n", read_buffer[0]);
  887   2          }
  888   1          I2C_Stop();
  889   1          
  890   1          // 阶段3：验证数据
  891   1          printf("3. DATA VERIFICATION:\r\n");
  892   1          
  893   1          for( i = 0; i < 5; i++) {
  894   2              if(read_buffer[i] == test_data[i]) {
  895   3                  printf("   Byte[%d]: 0x%02X == 0x%02X true\r\n", i, read_buffer[i], test_data[i]);
  896   3              } else {
  897   3                  printf("   Byte[%d]: 0x%02X != 0x%02X false\r\n", i, read_buffer[i], test_data[i]);
  898   3                  verify_ok = 0;
  899   3              }
  900   2          }
  901   1          
  902   1          if(verify_ok) {
  903   2              uart_write_string(UART_INDEX, "   DATA VERIFICATION: PASSED! \r\n");
  904   2          } else {
  905   2              uart_write_string(UART_INDEX, "   DATA VERIFICATION: FAILED\r\n");
  906   2          }
  907   1          
  908   1          printf("=== Enhanced Test Complete ===\r\n\r\n");
  909   1      }
  910          
  911          void Diagnose_SCL_Problem(void)
  912          {
  913   1          printf("=== TESTING NEW I2C PINS (P0.4-P0.7) ===\r\n" );
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 15  

  914   1          
  915   1          // 检查SCL引脚状态
  916   1          printf("Initial SCL states:\r\n");
  917   1          printf("Master SCL: %d, Slave SCL: %d\r\n", I2C_SCL, I2C_SLAVE_SCL);
  918   1          
  919   1          // 测试主机SCL输出能力
  920   1          printf("Testing master SCL output:\r\n");
  921   1          
  922   1          I2C_SCL = 0;
  923   1          system_delay_ms(10);
  924   1          printf("Master SCL set to 0: Master=%d, Slave=%d\r\n", I2C_SCL, I2C_SLAVE_SCL);
  925   1          
  926   1          I2C_SCL = 1;
  927   1          system_delay_ms(10);
  928   1          printf("Master SCL set to 1: Master=%d, Slave=%d\r\n", I2C_SCL, I2C_SLAVE_SCL);
  929   1          
  930   1          // 测试从机SCL输出能力
  931   1          printf("Testing slave SCL output:\r\n");
  932   1          
  933   1          I2C_SLAVE_SCL = 0;
  934   1          system_delay_ms(10);
  935   1          printf("Slave SCL set to 0: Master=%d, Slave=%d\r\n", I2C_SCL, I2C_SLAVE_SCL);
  936   1          
  937   1          I2C_SLAVE_SCL = 1;
  938   1          system_delay_ms(10);
  939   1          printf("Slave SCL set to 1: Master=%d, Slave=%d\r\n", I2C_SCL, I2C_SLAVE_SCL);
  940   1          
  941   1          printf("=== SCL DIAGNOSIS COMPLETE ===\r\n\r\n");
  942   1      }
  943          
  944          void Diagnose_All_P0_Pins(void)
  945          {
  946   1          int pin;
  947   1          u8 port_state;
  948   1          int i;
  949   1          printf("=== COMPLETE P0 PORT DIAGNOSIS ===\r\n");
  950   1          
  951   1          // 测试P0口所有引脚的输出能力
  952   1          for(pin = 0; pin < 8; pin++) {
  953   2              // 设置引脚为输出
  954   2              P0 = (1 << pin);  // 设置单个引脚为高，其他为低
  955   2              
  956   2              system_delay_ms(100);
  957   2              
  958   2              // 读取整个P0口的状态
  959   2              port_state = P0;
  960   2              
  961   2              printf("P0.%d set to 1 -> Port reads: 0x%02X (", pin, port_state);
  962   2              
  963   2              // 二进制显示
  964   2              for(i = 7; i >= 0; i--) {
  965   3                  printf("%d", (port_state >> i) & 1);
  966   3              }
  967   2              printf(")\r\n");
  968   2          }
  969   1          
  970   1          // 重置P0口
  971   1          P0 = 0xFF;
  972   1          printf("=== P0 PORT DIAGNOSIS COMPLETE ===\r\n\r\n");
  973   1      }
*** WARNING C183 IN LINE 386 OF ..\Hardware\IIC.c: dead assignment eliminated
*** WARNING C183 IN LINE 387 OF ..\Hardware\IIC.c: dead assignment eliminated
*** WARNING C184 IN LINE 386 OF ..\Hardware\IIC.c: value of 'heartbeat_counter' possibly undefined
*** WARNING C183 IN LINE 572 OF ..\Hardware\IIC.c: dead assignment eliminated
*** WARNING C183 IN LINE 572 OF ..\Hardware\IIC.c: dead assignment eliminated
*** WARNING C183 IN LINE 638 OF ..\Hardware\IIC.c: dead assignment eliminated
C251 COMPILER V5.60.0,  IIC                                                                18/11/25  17:04:56  PAGE 16  



Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4121     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        75         60
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =         9          8
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      3127     ------
End of Module Information.


C251 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
