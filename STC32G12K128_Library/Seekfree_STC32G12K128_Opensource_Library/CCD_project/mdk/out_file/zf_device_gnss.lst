C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_gnss
OBJECT MODULE PLACED IN .\out_file\zf_device_gnss.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\..\Libraries\zf_device\zf_device_gnss.c LARGE NOALIAS FLOAT64 WARNINGLE
                    -VEL(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..
                    -\..\libraries\zf_driver;..\user;..\code;..\Hardware) DEBUG PRINT(.\out_file\zf_device_gnss.lst) OBJECT(.\out_file\zf_dev
                    -ice_gnss.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * TC264 Opensourec Library ¼´£¨TC264 ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇ TC264 ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * TC264 ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          zf_device_gnss
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          ADS v1.9.20
   28          * ÊÊÓÃÆ½Ì¨          TC264D
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß               ±¸×¢
   33          * 2023-12-28       pudding            first version
   34          * 2024-01-30       pudding            ÐÂÔöRTK "D" ±¨Í·Ð­Òé
   35          *********************************************************************************************************
             -***********/
   36          /********************************************************************************************************
             -*************
   37          * ½ÓÏß¶¨Òå£º
   38          *                   ------------------------------------
   39          *                   Ä£¿é¹Ü½Å             µ¥Æ¬»ú¹Ü½Å
   40          *                   RX                  ²é¿´ zf_device_gnss.h ÖÐ GNSS_RX ºê¶¨Òå
   41          *                   TX                  ²é¿´ zf_device_gnss.h ÖÐ GNSS_TX ºê¶¨Òå
   42          *                   VCC                 3.3VµçÔ´
   43          *                   GND                 µçÔ´µØ
   44          *                   ------------------------------------
   45          *********************************************************************************************************
             -***********/
   46          
   47          #include "math.h"
   48          #include "zf_common_function.h"
   49          #include "zf_common_fifo.h"
   50          #include "zf_driver_delay.h"
   51          #include "zf_driver_uart.h"
   52          
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 2   

   53          #include "zf_device_gnss.h"
   54          
   55          #pragma warning disable = 183
   56          
   57          #define GNSS_BUFFER_SIZE    ( 128 )
   58          
   59          uint8                       gnss_flag = 0;                                  // 1£º²É¼¯Íê³ÉµÈ´ý´¦ÀíÊý¾Ý 0£
             -ºÃ»ÓÐ²É¼¯Íê³É
   60          gnss_info_struct            gnss;                                           // GPS½âÎöÖ®ºóµÄÊý¾Ý
   61              
   62          static  uint8               gnss_state = 0;                                 // 1£ºGPS³õÊ¼»¯Íê³É
   63          static  fifo_struct     gnss_receiver_fifo;                             //
   64          static  uint8               gnss_receiver_buffer[GNSS_BUFFER_SIZE];         // Êý¾Ý´æ·ÅÊý×é
   65          
   66          static  gps_state_enum      gnss_gga_state = GPS_STATE_RECEIVING;           // gga Óï¾ä×´Ì¬
   67          static  gps_state_enum      gnss_rmc_state = GPS_STATE_RECEIVING;           // rmc Óï¾ä×´Ì¬
   68          static  gps_state_enum      gnss_ths_state = GPS_STATE_RECEIVING;           // rmc Óï¾ä×´Ì¬
   69          
   70          static  uint8               gps_gga_buffer[GNSS_BUFFER_SIZE];
   71          static  uint8               gps_rmc_buffer[GNSS_BUFFER_SIZE];
   72          static  uint8               gps_ths_buffer[GNSS_BUFFER_SIZE];
   73          
   74          //-------------------------------------------------------------------------------------------------------
             -------------
   75          // º¯Êý¼ò½é     »ñÈ¡Ö¸¶¨ ',' ºóÃæµÄË÷Òý
   76          // ²ÎÊýËµÃ÷     num             µÚ¼¸¸ö¶ººÅ
   77          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®
   78          // ·µ»Ø²ÎÊý     uint8           ·µ»ØË÷Òý
   79          // Ê¹ÓÃÊ¾Àý     get_parameter_index(1, s);
   80          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
   81          //-------------------------------------------------------------------------------------------------------
             -------------
   82          static uint8 get_parameter_index (uint8 num, char *str)
   83          {
   84   1          uint8 i = 0, j = 0;
   85   1          char *temp = strchr(str, '\n');
   86   1          uint8 len = 0, len1 = 0;
   87   1      
   88   1          if(NULL != temp)
   89   1          {
   90   2              len = (uint8)((uint32)temp - (uint32)str + 1);
   91   2          }
   92   1      
   93   1          for(i = 0; i < len; i ++)
   94   1          {
   95   2              if(',' == str[i])
   96   2              {
   97   3                  j ++;
   98   3              }
   99   2              if(j == num)
  100   2              {
  101   3                  len1 =  i + 1;  
  102   3                  break;
  103   3              }
  104   2          }
  105   1      
  106   1          return len1;
  107   1      }
  108          
  109          //-------------------------------------------------------------------------------------------------------
             -------------
  110          // º¯Êý¼ò½é     ¸ø¶¨×Ö·û´®µÚÒ»¸ö ',' Ö®Ç°µÄÊý¾Ý×ª»»Îªint
  111          // ²ÎÊýËµÃ÷     *s              ×Ö·û´®
  112          // ·µ»Ø²ÎÊý     float           ·µ»ØÊýÖµ
  113          // Ê¹ÓÃÊ¾Àý     get_int_number(&buf[get_parameter_index(7, buf)]);
  114          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 3   

  115          //-------------------------------------------------------------------------------------------------------
             -------------
  116          static int get_int_number (char *s)
  117          {
  118   1          char buf[10];
  119   1          uint8 i = 0;
  120   1          int return_value = 0;
  121   1          i = get_parameter_index(1, s);
  122   1          i = i - 1;
  123   1          strncpy(buf, s, i);
  124   1          buf[i] = 0;
  125   1          return_value = func_str_to_int(buf);
  126   1          return return_value;
  127   1      }
  128                                                          
  129          //-------------------------------------------------------------------------------------------------------
             -------------
  130          // º¯Êý¼ò½é     ¸ø¶¨×Ö·û´®µÚÒ»¸ö ',' Ö®Ç°µÄÊý¾Ý×ª»»Îªfloat
  131          // ²ÎÊýËµÃ÷     *s              ×Ö·û´®
  132          // ·µ»Ø²ÎÊý     float           ·µ»ØÊýÖµ
  133          // Ê¹ÓÃÊ¾Àý     get_float_number(&buf[get_parameter_index(8, buf)]);
  134          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  135          //-------------------------------------------------------------------------------------------------------
             -------------
  136          static float get_float_number (char *s)
  137          {
  138   1          uint8 i = 0;
  139   1          char buf[15];
  140   1          float return_value = 0;
  141   1          
  142   1          i = get_parameter_index(1, s);
  143   1          i = i - 1;
  144   1          strncpy(buf, s, i);
  145   1          buf[i] = 0;
  146   1          return_value = (float)func_str_to_double(buf);
  147   1          return return_value;    
  148   1      }
  149                                              
  150          //-------------------------------------------------------------------------------------------------------
             -------------
  151          // º¯Êý¼ò½é     ¸ø¶¨×Ö·û´®µÚÒ»¸ö ',' Ö®Ç°µÄÊý¾Ý×ª»»Îªdouble
  152          // ²ÎÊýËµÃ÷     *s              ×Ö·û´®
  153          // ·µ»Ø²ÎÊý     double          ·µ»ØÊýÖµ
  154          // Ê¹ÓÃÊ¾Àý     get_double_number(&buf[get_parameter_index(3, buf)]);
  155          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  156          //-------------------------------------------------------------------------------------------------------
             -------------
  157          static double get_double_number (char *s)
  158          {
  159   1          uint8 i = 0;
  160   1          char buf[15];
  161   1          double return_value = 0;
  162   1          
  163   1          i = get_parameter_index(1, s);
  164   1          i = i - 1;
  165   1          strncpy(buf, s, i);
  166   1          buf[i] = 0;
  167   1          return_value = func_str_to_double(buf);
  168   1          return return_value;
  169   1      }
  170          
  171          //-------------------------------------------------------------------------------------------------------
             -------------
  172          // º¯Êý¼ò½é     ÊÀ½çÊ±¼ä×ª»»Îª±±¾©Ê±¼ä
  173          // ²ÎÊýËµÃ÷     *time           ±£´æµÄÊ±¼ä
  174          // ·µ»Ø²ÎÊý     void
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 4   

  175          // Ê¹ÓÃÊ¾Àý     utc_to_btc(&gnss->time);
  176          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  177          //-------------------------------------------------------------------------------------------------------
             -------------
  178          static void utc_to_btc (gps_time_struct *time)
  179          {
  180   1          uint8 day_num = 0;
  181   1          
  182   1          time->hour = time->hour + 8;
  183   1          if(23 < time->hour)
  184   1          {
  185   2              time->hour -= 24;
  186   2              time->day += 1;
  187   2      
  188   2              if(2 == time->month)
  189   2              {
  190   3                  day_num = 28;
  191   3                  if((0 == time->year % 4 && 0 != time->year % 100) || 0 == time->year % 400) // ÅÐ¶ÏÊÇ·ñÎªÈòÄê
  192   3                  {
  193   4                      day_num ++;                                                     // ÈòÔÂ 2ÔÂÎª29Ìì
  194   4                  }
  195   3              }
  196   2              else
  197   2              {
  198   3                  day_num = 31;                                                       // 1 3 5 7 8 10 12ÕâÐ©ÔÂ·
             -ÝÎª31Ìì
  199   3                  if(4  == time->month || 6  == time->month || 9  == time->month || 11 == time->month )
  200   3                  {
  201   4                      day_num = 30;
  202   4                  }
  203   3              }
  204   2              
  205   2              if(time->day > day_num)
  206   2              {
  207   3                  time->day = 1;
  208   3                  time->month ++;
  209   3                  if(12 < time->month)
  210   3                  {
  211   4                      time->month -= 12;
  212   4                      time->year ++;
  213   4                  }
  214   3              }
  215   2          }
  216   1      }
  217          
  218          //-------------------------------------------------------------------------------------------------------
             -------------
  219          // º¯Êý¼ò½é     RMCÓï¾ä½âÎö
  220          // ²ÎÊýËµÃ÷     *line           ½ÓÊÕµ½µÄÓï¾äÐÅÏ¢
  221          // ²ÎÊýËµÃ÷     *gnss            ±£´æ½âÎöºóµÄÊý¾Ý
  222          // ·µ»Ø²ÎÊý     uint8           1£º½âÎö³É¹¦ 0£ºÊý¾ÝÓÐÎÊÌâ²»ÄÜ½âÎö
  223          // Ê¹ÓÃÊ¾Àý     gps_gnrmc_parse((char *)data_buffer, &gnss);
  224          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  225          //-------------------------------------------------------------------------------------------------------
             -------------
  226          static uint8 gps_gnrmc_parse (char *line, gnss_info_struct *gnss)
  227          {
  228   1          uint8 state = 0, temp = 0;
  229   1          
  230   1          double  latitude = 0;                                                       // Î³¶È
  231   1          double  longitude = 0;                                                      // ¾­¶È
  232   1          
  233   1          double lati_cent_tmp = 0, lati_second_tmp = 0;
  234   1          double long_cent_tmp = 0, long_second_tmp = 0;
  235   1          float speed_tmp = 0;
  236   1          char *buf = line;
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 5   

  237   1          uint8 return_state = 0;
  238   1      
  239   1          state = buf[get_parameter_index(2, buf)];
  240   1      
  241   1          if('A' == state || 'D' == state)                                            // Èç¹ûÊý¾ÝÓÐÐ§ Ôò½âÎöÊý¾
             -Ý
  242   1          {
  243   2              return_state = 1;
  244   2              gnss->state = 1;
  245   2              gnss -> ns               = buf[get_parameter_index(4, buf)];
  246   2              gnss -> ew               = buf[get_parameter_index(6, buf)];
  247   2      
  248   2              latitude                = get_double_number(&buf[get_parameter_index(3, buf)]);
  249   2              longitude               = get_double_number(&buf[get_parameter_index(5, buf)]);
  250   2      
  251   2              gnss->latitude_degree    = (int)latitude / 100;                         // Î³¶È×ª»»Îª¶È·ÖÃë
  252   2              lati_cent_tmp           = (latitude - gnss->latitude_degree * 100);
  253   2              gnss->latitude_cent      = (int)lati_cent_tmp;
  254   2              lati_second_tmp         = (lati_cent_tmp - gnss->latitude_cent) * 6000;
  255   2              gnss->latitude_second    = (int)lati_second_tmp;
  256   2      
  257   2              gnss->longitude_degree   = (int)longitude / 100;                        // ¾­¶È×ª»»Îª¶È·ÖÃë
  258   2              long_cent_tmp           = (longitude - gnss->longitude_degree * 100);
  259   2              gnss->longitude_cent     = (int)long_cent_tmp;
  260   2              long_second_tmp         = (long_cent_tmp - gnss->longitude_cent) * 6000;
  261   2              gnss->longitude_second   = (int)long_second_tmp;
  262   2      
  263   2              gnss->latitude   = gnss->latitude_degree + lati_cent_tmp / 60;
  264   2              gnss->longitude  = gnss->longitude_degree + long_cent_tmp / 60;
  265   2      
  266   2              speed_tmp       = get_float_number(&buf[get_parameter_index(7, buf)]);  // ËÙ¶È(º£Àï/Ð¡Ê±)
  267   2              gnss->speed      = speed_tmp * 1.85f;                                   // ×ª»»Îª¹«Àï/Ð¡Ê±
  268   2              gnss->direction  = get_float_number(&buf[get_parameter_index(8, buf)]); // ½Ç¶È
  269   2          }
  270   1          else
  271   1          {
  272   2              gnss->state = 0;
  273   2          }
  274   1      
  275   1          // ÔÚ¶¨Î»Ã»ÓÐÉúÐ§Ç°Ò²ÊÇÓÐÊ±¼äÊý¾ÝµÄ£¬¿ÉÒÔÖ±½Ó½âÎö
  276   1          gnss->time.hour    = (buf[7] - '0') * 10 + (buf[8] - '0');                  // Ê±¼ä
  277   1          gnss->time.minute  = (buf[9] - '0') * 10 + (buf[10] - '0');
  278   1          gnss->time.second  = (buf[11] - '0') * 10 + (buf[12] - '0');
  279   1          temp = get_parameter_index(9, buf);
  280   1          gnss->time.day     = (buf[temp + 0] - '0') * 10 + (buf[temp + 1] - '0');    // ÈÕÆÚ
  281   1          gnss->time.month   = (buf[temp + 2] - '0') * 10 + (buf[temp + 3] - '0');
  282   1          gnss->time.year    = (buf[temp + 4] - '0') * 10 + (buf[temp + 5] - '0') + 2000;
  283   1      
  284   1          utc_to_btc(&gnss->time);
  285   1      
  286   1          return return_state;
  287   1      }
  288          
  289          //-------------------------------------------------------------------------------------------------------
             -------------
  290          // º¯Êý¼ò½é     GGAÓï¾ä½âÎö
  291          // ²ÎÊýËµÃ÷     *line           ½ÓÊÕµ½µÄÓï¾äÐÅÏ¢
  292          // ²ÎÊýËµÃ÷     *gnss            ±£´æ½âÎöºóµÄÊý¾Ý
  293          // ·µ»Ø²ÎÊý     uint8           1£º½âÎö³É¹¦ 0£ºÊý¾ÝÓÐÎÊÌâ²»ÄÜ½âÎö
  294          // Ê¹ÓÃÊ¾Àý     gps_gngga_parse((char *)data_buffer, &gnss);
  295          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  296          //-------------------------------------------------------------------------------------------------------
             -------------
  297          static uint8 gps_gngga_parse (char *line, gnss_info_struct *gnss)
  298          {
  299   1          uint8 state = 0;
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 6   

  300   1          char *buf = line;
  301   1          uint8 return_state = 0;
  302   1      
  303   1          state = buf[get_parameter_index(2, buf)];
  304   1      
  305   1          if(',' != state)
  306   1          {
  307   2              gnss->satellite_used = (uint8)get_int_number(&buf[get_parameter_index(7, buf)]);
  308   2              gnss->height         = get_float_number(&buf[get_parameter_index(9, buf)]) + get_float_number(&bu
             -f[get_parameter_index(11, buf)]);  // ¸ß¶È = º£°Î¸ß¶È + µØÇòÍÖÇòÃæÏà¶Ô´óµØË®×¼ÃæµÄ¸ß¶È
  309   2              return_state = 1;
  310   2          }
  311   1          
  312   1          return return_state;
  313   1      }
  314          
  315          //-------------------------------------------------------------------------------------------------------
             -------------
  316          // º¯Êý¼ò½é     THSÓï¾ä½âÎö
  317          // ²ÎÊýËµÃ÷     *line           ½ÓÊÕµ½µÄÓï¾äÐÅÏ¢
  318          // ²ÎÊýËµÃ÷     *gnss            ±£´æ½âÎöºóµÄÊý¾Ý
  319          // ·µ»Ø²ÎÊý     uint8           1£º½âÎö³É¹¦ 0£ºÊý¾ÝÓÐÎÊÌâ²»ÄÜ½âÎö
  320          // Ê¹ÓÃÊ¾Àý     gps_gnths_parse((char *)data_buffer, &gnss);
  321          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  322          //-------------------------------------------------------------------------------------------------------
             -------------
  323          static uint8 gps_gnths_parse (char *line, gnss_info_struct *gnss)
  324          {
  325   1          uint8 state = 0;
  326   1          char *buf = line;
  327   1          uint8 return_state = 0;
  328   1      
  329   1          state = buf[get_parameter_index(2, buf)];
  330   1      
  331   1          if('A' == state)
  332   1          {
  333   2              gnss->antenna_direction_state = 1;
  334   2              gnss->antenna_direction = get_float_number(&buf[get_parameter_index(1, buf)]);
  335   2              return_state = 1;
  336   2          }
  337   1          else
  338   1          {
  339   2              gnss->antenna_direction_state = 0;
  340   2          }
  341   1          
  342   1          return return_state;
  343   1      }
  344          
  345          //-------------------------------------------------------------------------------------------------------
             -------------
  346          // º¯Êý¼ò½é     ¼ÆËã´ÓµÚÒ»¸öµãµ½µÚ¶þ¸öµãµÄ¾àÀë
  347          // ²ÎÊýËµÃ÷     latitude1       µÚÒ»¸öµãµÄÎ³¶È
  348          // ²ÎÊýËµÃ÷     longitude1      µÚÒ»¸öµãµÄ¾­¶È
  349          // ²ÎÊýËµÃ÷     latitude2       µÚ¶þ¸öµãµÄÎ³¶È
  350          // ²ÎÊýËµÃ÷     longitude2      µÚ¶þ¸öµãµÄ¾­¶È
  351          // ·µ»Ø²ÎÊý     double          ·µ»ØÁ½µã¾àÀë
  352          // Ê¹ÓÃÊ¾Àý     get_two_points_distance(latitude1_1, longitude1, latitude2, longitude2);
  353          // ±¸×¢ÐÅÏ¢
  354          //-------------------------------------------------------------------------------------------------------
             -------------
  355          double get_two_points_distance (double latitude1, double longitude1, double latitude2, double longitude2)
  356          {  
  357   1          const double EARTH_RADIUS = 6378137;                                        // µØÇò°ë¾¶(µ¥Î»£ºm)
  358   1          double rad_latitude1 = 0;
  359   1          double rad_latitude2 = 0;
  360   1          double rad_longitude1 = 0;
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 7   

  361   1          double rad_longitude2 = 0;
  362   1          double distance = 0;
  363   1          double a = 0;
  364   1          double b = 0;
  365   1          
  366   1          rad_latitude1 = ANGLE_TO_RAD(latitude1);                                    // ¸ù¾Ý½Ç¶È¼ÆËã»¡¶È
  367   1          rad_latitude2 = ANGLE_TO_RAD(latitude2);
  368   1          rad_longitude1 = ANGLE_TO_RAD(longitude1);
  369   1          rad_longitude2 = ANGLE_TO_RAD(longitude2);
  370   1      
  371   1          a = rad_latitude1 - rad_latitude2;
  372   1          b = rad_longitude1 - rad_longitude2;
  373   1      
  374   1          distance = 2 * asin(sqrt(pow(sin(a / 2), 2) + cos(rad_latitude1) * cos(rad_latitude2) * pow(sin(b / 2
             -), 2)));   // google maps ÀïÃæÊµÏÖµÄËã·¨
  375   1          distance = distance * EARTH_RADIUS;  
  376   1      
  377   1          return distance;  
  378   1      }
  379          
  380          //-------------------------------------------------------------------------------------------------------
             -------------
  381          // º¯Êý¼ò½é     ¼ÆËã´ÓµÚÒ»¸öµãµ½µÚ¶þ¸öµãµÄ·½Î»½Ç
  382          // ²ÎÊýËµÃ÷     latitude1       µÚÒ»¸öµãµÄÎ³¶È
  383          // ²ÎÊýËµÃ÷     longitude1      µÚÒ»¸öµãµÄ¾­¶È
  384          // ²ÎÊýËµÃ÷     latitude2       µÚ¶þ¸öµãµÄÎ³¶È
  385          // ²ÎÊýËµÃ÷     longitude2      µÚ¶þ¸öµãµÄ¾­¶È
  386          // ·µ»Ø²ÎÊý     double          ·µ»Ø·½Î»½Ç£¨0ÖÁ360£©
  387          // Ê¹ÓÃÊ¾Àý     get_two_points_azimuth(latitude1_1, longitude1, latitude2, longitude2);
  388          // ±¸×¢ÐÅÏ¢
  389          //-------------------------------------------------------------------------------------------------------
             -------------
  390          double get_two_points_azimuth (double latitude1, double longitude1, double latitude2, double longitude2)
  391          {
  392   1              double x = 0;
  393   1              double y = 0;
  394   1              double angle = 0;
  395   1              
  396   1          latitude1 = ANGLE_TO_RAD(latitude1);
  397   1          latitude2 = ANGLE_TO_RAD(latitude2);
  398   1          longitude1 = ANGLE_TO_RAD(longitude1);
  399   1          longitude2 = ANGLE_TO_RAD(longitude2);
  400   1      
  401   1          x     = sin(longitude2 - longitude1) * cos(latitude2);
  402   1          y     = cos(latitude1) * sin(latitude2) - sin(latitude1) * cos(latitude2) * cos(longitude2 - longitud
             -e1);
  403   1          angle = RAD_TO_ANGLE(atan2(x, y));
  404   1          return ((0 < angle) ? angle : (angle + 360));
  405   1      }
  406          
  407          //-------------------------------------------------------------------------------------------------------
             -------------
  408          // º¯Êý¼ò½é     ½âÎöGPSÊý¾Ý
  409          // ²ÎÊýËµÃ÷     void
  410          // ·µ»Ø²ÎÊý     uint8           0-½âÎö³É¹¦ 1-½âÎöÊ§°Ü ¿ÉÄÜÊý¾Ý°ü´íÎó
  411          // Ê¹ÓÃÊ¾Àý     gps_data_parse();
  412          // ±¸×¢ÐÅÏ¢
  413          //-------------------------------------------------------------------------------------------------------
             -------------
  414          uint8 gnss_data_parse (void)
  415          {
  416   1          uint8 return_state = 0;
  417   1          uint8 check_buffer[5] = {'0', 'x', 0x00, 0x00, 0x00};
  418   1          uint8 bbc_xor_origin = 0;
  419   1          uint8 bbc_xor_calculation = 0;
  420   1          uint32 data_len = 0;
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 8   

  421   1      
  422   1          do
  423   1          {
  424   2              if(GPS_STATE_RECEIVED == gnss_rmc_state)
  425   2              {
  426   3                  gnss_rmc_state = GPS_STATE_PARSING;
  427   3                  strncpy((char *)&check_buffer[2], strchr((const char *)gps_rmc_buffer, '*') + 1, 2);
  428   3                  bbc_xor_origin = (uint8)func_str_to_hex((char *)check_buffer);
  429   3                  for(bbc_xor_calculation = gps_rmc_buffer[1], data_len = 2; '*' != gps_rmc_buffer[data_len]; d
             -ata_len ++)
  430   3                  {
  431   4                      bbc_xor_calculation ^= gps_rmc_buffer[data_len];
  432   4                  }
  433   3                  if(bbc_xor_calculation != bbc_xor_origin)
  434   3                  {
  435   4                      // Êý¾ÝÐ£ÑéÊ§°Ü
  436   4                      return_state = 1;
  437   4                      break;
  438   4                  }
  439   3                  
  440   3                  gps_gnrmc_parse((char *)gps_rmc_buffer, &gnss);
  441   3              }
  442   2              gnss_rmc_state = GPS_STATE_RECEIVING;
  443   2              
  444   2              if(GPS_STATE_RECEIVED == gnss_gga_state)
  445   2              {
  446   3                  gnss_gga_state = GPS_STATE_PARSING;
  447   3                  strncpy((char *)&check_buffer[2], strchr((const char *)gps_gga_buffer, '*') + 1, 2);
  448   3                  bbc_xor_origin = (uint8)func_str_to_hex((char *)check_buffer);
  449   3                  
  450   3                  for(bbc_xor_calculation = gps_gga_buffer[1], data_len = 2; '*' != gps_gga_buffer[data_len]; d
             -ata_len ++)
  451   3                  {
  452   4                      bbc_xor_calculation ^= gps_gga_buffer[data_len];
  453   4                  }
  454   3                  if(bbc_xor_calculation != bbc_xor_origin)
  455   3                  {
  456   4                      // Êý¾ÝÐ£ÑéÊ§°Ü
  457   4                      return_state = 1;
  458   4                      break;
  459   4                  }
  460   3                  
  461   3                  gps_gngga_parse((char *)gps_gga_buffer, &gnss);
  462   3              }
  463   2              gnss_gga_state = GPS_STATE_RECEIVING;
  464   2              
  465   2              if(GPS_STATE_RECEIVED == gnss_ths_state)
  466   2              {
  467   3                  gnss_ths_state = GPS_STATE_PARSING;
  468   3                  strncpy((char *)&check_buffer[2], strchr((const char *)gps_ths_buffer, '*') + 1, 2);
  469   3                  bbc_xor_origin = (uint8)func_str_to_hex((char *)check_buffer);
  470   3                  
  471   3                  for(bbc_xor_calculation = gps_ths_buffer[1], data_len = 2; '*' != gps_ths_buffer[data_len]; d
             -ata_len ++)
  472   3                  {
  473   4                      bbc_xor_calculation ^= gps_ths_buffer[data_len];
  474   4                  }
  475   3                  if(bbc_xor_calculation != bbc_xor_origin)
  476   3                  {
  477   4                      // Êý¾ÝÐ£ÑéÊ§°Ü
  478   4                      return_state = 1;
  479   4                      break;
  480   4                  }
  481   3                  
  482   3                  gps_gnths_parse((char *)gps_ths_buffer, &gnss);
  483   3              }
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 9   

  484   2              gnss_ths_state = GPS_STATE_RECEIVING;
  485   2              
  486   2          }while(0);
  487   1          return return_state;
  488   1      }
  489          
  490          
  491          //-------------------------------------------------------------------------------------------------------
             -------------
  492          // º¯Êý¼ò½é     GPS´®¿Ú»Øµ÷º¯Êý
  493          // ²ÎÊýËµÃ÷     void
  494          // ·µ»Ø²ÎÊý     void
  495          // Ê¹ÓÃÊ¾Àý     gps_uart_callback();
  496          // ±¸×¢ÐÅÏ¢     ´Ëº¯ÊýÐèÒªÔÚ´®¿Ú½ÓÊÕÖÐ¶ÏÄÚ½øÐÐµ÷ÓÃ
  497          //-------------------------------------------------------------------------------------------------------
             -------------
  498          void gnss_uart_callback (void)
  499          {
  500   1          uint8 temp_gps[6];
  501   1          uint32 temp_length = 0;
  502   1      
  503   1      
  504   1      
  505   1      
  506   1          if(gnss_state)
  507   1          {
  508   2              uint8 dat;
  509   2              while(uart_query_byte(GNSS_UART, &dat))
  510   2              {
  511   3                  fifo_write_buffer(&gnss_receiver_fifo, &dat, 1);
  512   3              }
  513   2              
  514   2              if('\n' == dat)
  515   2              {
  516   3                  // ¶ÁÈ¡Ç°6¸öÊý¾Ý ÓÃÓÚÅÐ¶ÏÓï¾äÀàÐÍ
  517   3                  temp_length = 6;
  518   3                  fifo_read_buffer(&gnss_receiver_fifo, temp_gps, &temp_length, FIFO_READ_ONLY);
  519   3                  
  520   3                  // ¸ù¾Ý²»Í¬ÀàÐÍ½«Êý¾Ý¿½±´µ½²»Í¬µÄ»º³åÇø
  521   3                  if(0 == strncmp((char *)&temp_gps[3], "RMC", 3))
  522   3                  {
  523   4                      // Èç¹ûÃ»ÓÐÔÚ½âÎöÊý¾ÝÔò¸üÐÂ»º³åÇøµÄÊý¾Ý
  524   4                      if(GPS_STATE_PARSING != gnss_rmc_state)
  525   4                      {
  526   5                          gnss_rmc_state = GPS_STATE_RECEIVED;
  527   5                          temp_length = fifo_used(&gnss_receiver_fifo);
  528   5                          fifo_read_buffer(&gnss_receiver_fifo, gps_rmc_buffer, &temp_length, FIFO_READ_AND_CLE
             -AN);
  529   5                      }
  530   4                  }
  531   3                  else if(0 == strncmp((char *)&temp_gps[3], "GGA", 3))
  532   3                  {
  533   4                      // Èç¹ûÃ»ÓÐÔÚ½âÎöÊý¾ÝÔò¸üÐÂ»º³åÇøµÄÊý¾Ý
  534   4                      if(GPS_STATE_PARSING != gnss_gga_state)
  535   4                      {
  536   5                          gnss_gga_state = GPS_STATE_RECEIVED;
  537   5                          temp_length = fifo_used(&gnss_receiver_fifo);
  538   5                          fifo_read_buffer(&gnss_receiver_fifo, gps_gga_buffer, &temp_length, FIFO_READ_AND_CLE
             -AN);
  539   5                      }
  540   4                  }
  541   3                  else if(0 == strncmp((char *)&temp_gps[3], "THS", 3))
  542   3                  {
  543   4                      // Èç¹ûÃ»ÓÐÔÚ½âÎöÊý¾ÝÔò¸üÐÂ»º³åÇøµÄÊý¾Ý
  544   4                      if(GPS_STATE_PARSING != gnss_ths_state)
  545   4                      {
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 10  

  546   5                          gnss_ths_state = GPS_STATE_RECEIVED;
  547   5                          temp_length = fifo_used(&gnss_receiver_fifo);
  548   5                          fifo_read_buffer(&gnss_receiver_fifo, gps_ths_buffer, &temp_length, FIFO_READ_AND_CLE
             -AN);
  549   5                      }
  550   4                  }
  551   3                  
  552   3                  // Í³Ò»½«FIFOÇå¿Õ
  553   3                  fifo_clear(&gnss_receiver_fifo);
  554   3      
  555   3                  gnss_flag = 1;
  556   3              }
  557   2          }
  558   1      }
  559          
  560          //-------------------------------------------------------------------------------------------------------
             -------------
  561          // º¯Êý¼ò½é     GPS³õÊ¼»¯
  562          // ²ÎÊýËµÃ÷     void
  563          // ·µ»Ø²ÎÊý     void
  564          // Ê¹ÓÃÊ¾Àý     gps_init();
  565          // ±¸×¢ÐÅÏ¢
  566          //-------------------------------------------------------------------------------------------------------
             -------------
  567          void gnss_init (gps_device_enum gps_device)
  568          {
  569   1          const uint8 set_rate[]      = {0xF1, 0xD9, 0x06, 0x42, 0x14, 0x00, 0x00, 0x0A, 0x05, 0x00, 0x64, 0x00
             -, 0x00, 0x00, 0x60, 0xEA, 0x00, 0x00, 0xD0, 0x07, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0xB8, 0xED};
  570   1          const uint8 open_gga[]      = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x00, 0x01, 0xFB, 0x10};
  571   1          const uint8 open_rmc[]      = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x05, 0x01, 0x00, 0x1A};
  572   1          
  573   1          const uint8 close_gll[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x01, 0x00, 0xFB, 0x11};
  574   1          const uint8 close_gsa[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x02, 0x00, 0xFC, 0x13};
  575   1          const uint8 close_grs[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x03, 0x00, 0xFD, 0x15};
  576   1          const uint8 close_gsv[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x04, 0x00, 0xFE, 0x17};
  577   1          const uint8 close_vtg[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x06, 0x00, 0x00, 0x1B};
  578   1          const uint8 close_zda[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x07, 0x00, 0x01, 0x1D};
  579   1          const uint8 close_gst[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x08, 0x00, 0x02, 0x1F};
  580   1          const uint8 close_txt[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x40, 0x00, 0x3A, 0x8F};
  581   1          const uint8 close_txt_ant[] = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x20, 0x00, 0x1A, 0x4F};
  582   1          
  583   1          if((TAU1201 == gps_device) || (GN42A == gps_device))
  584   1          {
  585   2              fifo_init(&gnss_receiver_fifo, FIFO_DATA_8BIT, gnss_receiver_buffer, GNSS_BUFFER_SIZE);
  586   2              system_delay_ms(500);                                                   // µÈ´ýGPSÆô¶¯ºó¿ªÊ¼³õÊ¼»
             -¯
  587   2              uart_init(GNSS_UART, 115200, GNSS_RX, GNSS_TX);
  588   2      
  589   2              uart_write_buffer(GNSS_UART, (uint8 *)set_rate, sizeof(set_rate));      // ÉèÖÃGPS¸üÐÂËÙÂÊÎª10hz 
             -Èç¹û²»µ÷ÓÃ´ËÓï¾äÔòÄ¬ÈÏÎª1hz
  590   2              system_delay_ms(200);   
  591   2                  
  592   2              uart_write_buffer(GNSS_UART, (uint8 *)open_rmc, sizeof(open_rmc));      // ¿ªÆôrmcÓï¾ä
  593   2              system_delay_ms(50);    
  594   2              uart_write_buffer(GNSS_UART, (uint8 *)open_gga, sizeof(open_gga));      // ¿ªÆôggaÓï¾ä
  595   2              system_delay_ms(50);
  596   2              uart_write_buffer(GNSS_UART, (uint8 *)close_gll, sizeof(close_gll));
  597   2              system_delay_ms(50);
  598   2              uart_write_buffer(GNSS_UART, (uint8 *)close_gsa, sizeof(close_gsa));
  599   2              system_delay_ms(50);
  600   2              uart_write_buffer(GNSS_UART, (uint8 *)close_grs, sizeof(close_grs));
  601   2              system_delay_ms(50);
  602   2              uart_write_buffer(GNSS_UART, (uint8 *)close_gsv, sizeof(close_gsv));
  603   2              system_delay_ms(50);
  604   2              uart_write_buffer(GNSS_UART, (uint8 *)close_vtg, sizeof(close_vtg));
  605   2              system_delay_ms(50);
C251 COMPILER V5.60.0,  zf_device_gnss                                                     18/11/25  17:05:57  PAGE 11  

  606   2              uart_write_buffer(GNSS_UART, (uint8 *)close_zda, sizeof(close_zda));
  607   2              system_delay_ms(50);
  608   2              uart_write_buffer(GNSS_UART, (uint8 *)close_gst, sizeof(close_gst));
  609   2              system_delay_ms(50);
  610   2              uart_write_buffer(GNSS_UART, (uint8 *)close_txt, sizeof(close_txt));
  611   2              system_delay_ms(50);
  612   2              uart_write_buffer(GNSS_UART, (uint8 *)close_txt_ant, sizeof(close_txt_ant));
  613   2              system_delay_ms(50);
  614   2      
  615   2              gnss_state = 1;
  616   2              uart_rx_interrupt(GNSS_UART, 1);
  617   2          }
  618   1          else if(GN43RFA == gps_device)
  619   1          {
  620   2              // GN43RFA RTKÄ£¿é²»ÐèÒª½øÐÐ²ÎÊýÉèÖÃ£¬Èç¹ûÐèÒªÐÞ¸Ä²ÎÊýÓ¦¸ÃÊ¹ÓÃ×¨ÓÃµÄÉÏÎ»»úÐÞ¸Ä²ÎÊý
  621   2              fifo_init(&gnss_receiver_fifo, FIFO_DATA_8BIT, gnss_receiver_buffer, GNSS_BUFFER_SIZE);
  622   2              uart_init(GNSS_UART, 115200, GNSS_RX, GNSS_TX);
  623   2              gnss_state = 1;
  624   2              uart_rx_interrupt(GNSS_UART, 1);
  625   2          }
  626   1          
  627   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5010     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       599        402
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       199     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
