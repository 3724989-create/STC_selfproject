C251 COMPILER V5.60.0,  AI8051U_CAN                                                        18/11/25  13:07:43  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE AI8051U_CAN
OBJECT MODULE PLACED IN .\out_file\AI8051U_CAN.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\lq_libraries\Driver\Src\AI8051U_CAN.c LARGE NOALIAS FLOAT64 WARNINGLEVE
                    -L(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\.
                    -.\libraries\zf_driver;..\user;..\code;..\Hardware;..\lq_libraries\LQ_LIB\Inc;..\lq_libraries\Include;..\lq_libraries\Dri
                    -ver\Inc) DEBUG PRINT(.\out_file\AI8051U_CAN.lst) OBJECT(.\out_file\AI8051U_CAN.obj) 

stmt  level    source

    1          
    2          /*---------------------------------------------------------------------*/
    3          /* ------------------- Web: www.STCAI.com -----------------------------*/
    4          /*---------------------------------------------------------------------*/
    5          
    6          #include "AI8051U_CAN.h"
    7          
    8          CAN_DataDef CAN1_Tx;
    9          CAN_DataDef CAN1_Rx[8];
   10          
   11          CAN_DataDef CAN2_Tx;
   12          CAN_DataDef CAN2_Rx[8];
   13          
   14          //========================================================================
   15          // º¯Êý: u8 ReadReg(u8 addr)
   16          // ÃèÊö: CAN¹¦ÄÜ¼Ä´æÆ÷¶ÁÈ¡º¯Êý¡£
   17          // ²ÎÊý: CAN¹¦ÄÜ¼Ä´æÆ÷µØÖ·.
   18          // ·µ»Ø: CAN¹¦ÄÜ¼Ä´æÆ÷Êý¾Ý.
   19          // °æ±¾: VER1.0
   20          // ÈÕÆÚ: 2020-11-16
   21          // ±¸×¢:
   22          //========================================================================
   23          u8 CanReadReg(u8 addr)
   24          {
   25   1          u8 dat;
   26   1          CANAR = addr;
   27   1          dat = CANDR;
   28   1          return dat;
   29   1      }
   30          
   31          //========================================================================
   32          // º¯Êý: void WriteReg(u8 addr, u8 dat)
   33          // ÃèÊö: CAN¹¦ÄÜ¼Ä´æÆ÷ÅäÖÃº¯Êý¡£
   34          // ²ÎÊý: CAN¹¦ÄÜ¼Ä´æÆ÷µØÖ·, CAN¹¦ÄÜ¼Ä´æÆ÷Êý¾Ý.
   35          // ·µ»Ø: none.
   36          // °æ±¾: VER1.0
   37          // ÈÕÆÚ: 2020-11-16
   38          // ±¸×¢:
   39          //========================================================================
   40          void CanWriteReg(u8 addr, u8 dat)
   41          {
   42   1          CANAR = addr;
   43   1          CANDR = dat;
   44   1      }
   45          
   46          //========================================================================
   47          // º¯Êý: void CAN_Inilize(u8 CANx, CAN_InitTypeDef *CAN)
   48          // ÃèÊö: CAN ³õÊ¼»¯³ÌÐò.
   49          // ²ÎÊý: CAN: ½á¹¹²ÎÊý,Çë²Î¿¼CAN.hÀïµÄ¶¨Òå.
   50          // ·µ»Ø: none.
   51          // °æ±¾: V1.0, 2021-06-02
   52          //========================================================================
   53          void CAN_Inilize(u8 CANx, CAN_InitTypeDef *CAN)
   54          {
   55   1          if (CANx == CAN1)
   56   1          {
C251 COMPILER V5.60.0,  AI8051U_CAN                                                        18/11/25  13:07:43  PAGE 2   

   57   2              CANSEL = CAN1;         // Ñ¡ÔñCAN1Ä£¿é
   58   2              CanWriteReg(MR, 0x04); // Ê¹ÄÜ Reset Mode
   59   2      
   60   2              if (CAN->CAN_Enable == ENABLE)
   61   2                  CANEN = 1; // Ê¹ÄÜCAN1Ä£¿é
   62   2              else
   63   2                  CANEN = 0; // ¹Ø±ÕCAN1Ä£¿é
   64   2      
   65   2              CanWriteReg(BTR0, (u8)((CAN->CAN_SJW << 6) + CAN->CAN_BRP));
   66   2              CanWriteReg(BTR1, (u8)((CAN->CAN_SAM << 7) + (CAN->CAN_TSG2 << 4) + CAN->CAN_TSG1));
   67   2      
   68   2              CanWriteReg(ACR0, CAN->CAN_ACR0); // ×ÜÏßÑéÊÕ´úÂë¼Ä´æÆ÷
   69   2              CanWriteReg(ACR1, CAN->CAN_ACR1);
   70   2              CanWriteReg(ACR2, CAN->CAN_ACR2);
   71   2              CanWriteReg(ACR3, CAN->CAN_ACR3);
   72   2              CanWriteReg(AMR0, CAN->CAN_AMR0); // ×ÜÏßÑéÊÕÆÁ±Î¼Ä´æÆ÷
   73   2              CanWriteReg(AMR1, CAN->CAN_AMR1);
   74   2              CanWriteReg(AMR2, CAN->CAN_AMR2);
   75   2              CanWriteReg(AMR3, CAN->CAN_AMR3);
   76   2      
   77   2              CanWriteReg(ISR, 0xff);                                               // ÇåÖÐ¶Ï±êÖ¾
   78   2              CanWriteReg(IMR, CAN->CAN_IMR);                                       // ÖÐ¶Ï¼Ä´æÆ÷ÉèÖÃ
   79   2              CanWriteReg(MR, 0x00 | (CAN->CAN_ListenOnly << 1) | CAN->CAN_Filter); // ÍË³ö Reset Mode
   80   2          }
   81   1          else if (CANx == CAN2)
   82   1          {
   83   2              CANSEL = CAN2; // Ñ¡ÔñCAN2Ä£¿é
   84   2      
   85   2              CanWriteReg(MR, 0x04); // Ê¹ÄÜ Reset Mode
   86   2      
   87   2              if (CAN->CAN_Enable == ENABLE)
   88   2                  CAN2EN = 1; // Ê¹ÄÜCAN2Ä£¿é
   89   2              else
   90   2                  CAN2EN = 0; // ¹Ø±ÕCAN2Ä£¿é
   91   2      
   92   2              CanWriteReg(BTR0, (u8)((CAN->CAN_SJW << 6) + CAN->CAN_BRP));
   93   2              CanWriteReg(BTR1, (u8)((CAN->CAN_SAM << 7) + (CAN->CAN_TSG2 << 4) + CAN->CAN_TSG1));
   94   2      
   95   2              CanWriteReg(ACR0, CAN->CAN_ACR0); // ×ÜÏßÑéÊÕ´úÂë¼Ä´æÆ÷
   96   2              CanWriteReg(ACR1, CAN->CAN_ACR1);
   97   2              CanWriteReg(ACR2, CAN->CAN_ACR2);
   98   2              CanWriteReg(ACR3, CAN->CAN_ACR3);
   99   2              CanWriteReg(AMR0, CAN->CAN_AMR0); // ×ÜÏßÑéÊÕÆÁ±Î¼Ä´æÆ÷
  100   2              CanWriteReg(AMR1, CAN->CAN_AMR1);
  101   2              CanWriteReg(AMR2, CAN->CAN_AMR2);
  102   2              CanWriteReg(AMR3, CAN->CAN_AMR3);
  103   2      
  104   2              CanWriteReg(ISR, 0xff);                                               // ÇåÖÐ¶Ï±êÖ¾
  105   2              CanWriteReg(IMR, CAN->CAN_IMR);                                       // ÖÐ¶Ï¼Ä´æÆ÷ÉèÖÃ
  106   2              CanWriteReg(MR, 0x00 | (CAN->CAN_ListenOnly << 1) | CAN->CAN_Filter); // ÍË³ö Reset Mode
  107   2          }
  108   1      
  109   1          B_Can1Send = 0;
  110   1          B_Can2Send = 0;
  111   1      }
  112          
  113          //========================================================================
  114          // º¯Êý: void CanReadFifo(CAN_DataDef *CAN)
  115          // ÃèÊö: ¶ÁÈ¡CAN»º³åÇøÊý¾Ýº¯Êý¡£
  116          // ²ÎÊý: *CAN: ´æ·ÅCAN×ÜÏß¶ÁÈ¡Êý¾Ý.½á¹¹²ÎÊý,Çë²Î¿¼CAN.hÀïµÄ¶¨Òå.
  117          // ·µ»Ø: none.
  118          // °æ±¾: VER2.0
  119          // ÈÕÆÚ: 2023-01-31
  120          // ±¸×¢:
  121          //========================================================================
  122          void CanReadFifo(CAN_DataDef *CAN)
C251 COMPILER V5.60.0,  AI8051U_CAN                                                        18/11/25  13:07:43  PAGE 3   

  123          {
  124   1          u8 i;
  125   1          u8 pdat[5];
  126   1          u8 RX_Index = 0;
  127   1      
  128   1          pdat[0] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
  129   1      
  130   1          if (pdat[0] & 0x80) // ÅÐ¶ÏÊÇ±ê×¼Ö¡»¹ÊÇÀ©Õ¹Ö¡
  131   1          {
  132   2              pdat[1] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // À©Õ¹Ö¡IDÕ¼4¸ö×Ö½Ú
  133   2              pdat[2] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
  134   2              pdat[3] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
  135   2              pdat[4] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
  136   2              CAN->ID = (((u32)pdat[1] << 24) + ((u32)pdat[2] << 16) + ((u32)pdat[3] << 8) + pdat[4]) >> 3;
  137   2          }
  138   1          else
  139   1          {
  140   2              pdat[1] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // ±ê×¼Ö¡IDÕ¼2¸ö×Ö½Ú
  141   2              pdat[2] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
  142   2              CAN->ID = ((pdat[1] << 8) + pdat[2]) >> 5;
  143   2          }
  144   1      
  145   1          CAN->FF = pdat[0] >> 7;  // Ö¡¸ñÊ½
  146   1          CAN->RTR = pdat[0] >> 6; // Ö¡ÀàÐÍ
  147   1          CAN->DLC = pdat[0];      // Êý¾Ý³¤¶È
  148   1      
  149   1          for (i = 0; ((i < CAN->DLC) && (i < 8)); i++) // ¶ÁÈ¡Êý¾Ý³¤¶ÈÎªlen£¬×î¶à²»³¬¹ý8
  150   1          {
  151   2              CAN->DataBuffer[i] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // ¶ÁÈ¡ÓÐÐ§Êý¾Ý
  152   2          }
  153   1          while (RX_Index & 3) // ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
  154   1          {
  155   2              CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // ¶ÁÈ¡Ìî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º³åÇø¿Õ¼ä£¬²
             -»×ã²¹0
  156   2          }
  157   1      }
  158          
  159          //========================================================================
  160          // º¯Êý: u8 CanReadMsg(void)
  161          // ÃèÊö: CAN½ÓÊÕÊý¾Ýº¯Êý¡£
  162          // ²ÎÊý: *CANx: ´æ·ÅCAN×ÜÏß¶ÁÈ¡Êý¾Ý..
  163          // ·µ»Ø: Ö¡¸öÊý.
  164          // °æ±¾: VER2.0
  165          // ÈÕÆÚ: 2023-01-31
  166          // ±¸×¢:
  167          //========================================================================
  168          u8 CanReadMsg(CAN_DataDef *CAN)
  169          {
  170   1          u8 i;
  171   1          u8 n = 0;
  172   1      
  173   1          do
  174   1          {
  175   2              CanReadFifo(&CAN[n++]); // ¶ÁÈ¡½ÓÊÕ»º³åÇøÊý¾Ý
  176   2              i = CanReadReg(SR);
  177   2          } while (i & 0x80); // ÅÐ¶Ï½ÓÊÕ»º³åÇøÀïÊÇ·ñ»¹ÓÐÊý¾Ý£¬ÓÐµÄ»°¼ÌÐø¶ÁÈ¡
  178   1      
  179   1          return n; // ·µ»ØÖ¡¸öÊý
  180   1      }
  181          
  182          //========================================================================
  183          // º¯Êý: void CanSendMsg(CAN_DataDef *CAN)
  184          // ÃèÊö: CAN·¢ËÍ±ê×¼Ö¡º¯Êý¡£
  185          // ²ÎÊý: *CANx: ´æ·ÅCAN×ÜÏß·¢ËÍÊý¾Ý..
  186          // ·µ»Ø: none.
  187          // °æ±¾: VER1.0
C251 COMPILER V5.60.0,  AI8051U_CAN                                                        18/11/25  13:07:43  PAGE 4   

  188          // ÈÕÆÚ: 2020-11-19
  189          // ±¸×¢:
  190          //========================================================================
  191          void CanSendMsg(CAN_DataDef *CAN)
  192          {
  193   1          u32 CanID;
  194   1          u8 RX_Index, i;
  195   1      
  196   1          if (CANSEL) // ÅÐ¶ÏÊÇ·ñCAN2
  197   1          {
  198   2              i = 200;
  199   2              while ((--i) && (B_Can2Send))
  200   2                  ; // µÈ´ýCAN2ÉÏ´Î·¢ËÍÍê³É
  201   2          }
  202   1          else
  203   1          {
  204   2              i = 200;
  205   2              while ((--i) && (B_Can1Send))
  206   2                  ; // µÈ´ýCAN1ÉÏ´Î·¢ËÍÍê³É
  207   2          }
  208   1      
  209   1          if (CAN->FF) // ÅÐ¶ÏÊÇ·ñÀ©Õ¹Ö¡
  210   1          {
  211   2              CanID = CAN->ID << 3;
  212   2              CanWriteReg(TX_BUF0, CAN->DLC | ((u8)CAN->RTR << 6) | 0x80); // bit7: ±ê×¼Ö¡(0)/À©Õ¹Ö¡(1), bit6: 
             -Êý¾ÝÖ¡(0)/Ô¶³ÌÖ¡(1), bit3~bit0: Êý¾Ý³¤¶È(DLC)
  213   2              CanWriteReg(TX_BUF1, (u8)(CanID >> 24));
  214   2              CanWriteReg(TX_BUF2, (u8)(CanID >> 16));
  215   2              CanWriteReg(TX_BUF3, (u8)(CanID >> 8));
  216   2      
  217   2              CanWriteReg(TX_BUF0, (u8)CanID);
  218   2      
  219   2              RX_Index = 1;
  220   2              for (i = 0; ((i < CAN->DLC) && (i < 8)); i++) // Êý¾Ý³¤¶ÈÎªDLC£¬×î¶à²»³¬¹ý8
  221   2              {
  222   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), CAN->DataBuffer[i]); // Ð´ÈëÓÐÐ§Êý¾Ý
  223   3              }
  224   2              while (RX_Index & 3) // ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
  225   2              {
  226   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), 0x00); // Ð´ÈëÌî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º
             -³åÇø¿Õ¼ä£¬²»×ã²¹0
  227   3              }
  228   2          }
  229   1          else // ·¢ËÍ±ê×¼Ö¡
  230   1          {
  231   2              CanID = (u16)(CAN->ID << 5);
  232   2              CanWriteReg(TX_BUF0, CAN->DLC | ((u8)CAN->RTR << 6)); // bit7: ±ê×¼Ö¡(0)/À©Õ¹Ö¡(1), bit6: Êý¾ÝÖ¡(
             -0)/Ô¶³ÌÖ¡(1), bit3~bit0: Êý¾Ý³¤¶È(DLC)
  233   2              CanWriteReg(TX_BUF1, (u8)(CanID >> 8));
  234   2              CanWriteReg(TX_BUF2, (u8)CanID);
  235   2      
  236   2              RX_Index = 3;
  237   2              for (i = 0; ((i < CAN->DLC) && (i < 8)); i++) // Êý¾Ý³¤¶ÈÎªDLC£¬×î¶à²»³¬¹ý8
  238   2              {
  239   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), CAN->DataBuffer[i]); // Ð´ÈëÓÐÐ§Êý¾Ý
  240   3              }
  241   2              while (RX_Index & 3) // ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
  242   2              {
  243   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), 0x00); // Ð´ÈëÌî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º
             -³åÇø¿Õ¼ä£¬²»×ã²¹0
  244   3              }
  245   2          }
  246   1          CanWriteReg(CMR, 0x04); // ·¢ÆðÒ»´ÎÖ¡´«Êä
  247   1      
  248   1          if (CANSEL) // ÅÐ¶ÏÊÇ·ñCAN2
  249   1          {
C251 COMPILER V5.60.0,  AI8051U_CAN                                                        18/11/25  13:07:43  PAGE 5   

  250   2              B_Can2Send = 1; // ÉèÖÃCAN2·¢ËÍÃ¦±êÖ¾
  251   2          }
  252   1          else
  253   1          {
  254   2              B_Can1Send = 1; // ÉèÖÃCAN1·¢ËÍÃ¦±êÖ¾
  255   2          }
  256   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1198     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       234         15
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
