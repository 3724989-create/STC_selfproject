C251 COMPILER V5.60.0,  LQ_UTM                                                             18/11/25  13:07:52  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE LQ_UTM
OBJECT MODULE PLACED IN .\out_file\LQ_UTM.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\lq_libraries\LQ_LIB\Src\LQ_UTM.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) 
                    -OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\lib
                    -raries\zf_driver;..\user;..\code;..\Hardware;..\lq_libraries\LQ_LIB\Inc;..\lq_libraries\Include;..\lq_libraries\Driver\I
                    -nc) DEBUG PRINT(.\out_file\LQ_UTM.lst) OBJECT(.\out_file\LQ_UTM.obj) 

stmt  level    source

    1          #include "include.h"
    2          
    3          #include "LQ_UTM.h"
    4          #include "LQ_BDGPS.h"
    5          
    6          double rad(double _d) {
    7   1          return _d * PI / 180.0;
    8   1      }
    9          
   10          int get_zone(double lon)
   11          {
   12   1          int zone = (int)floor((lon + 180.0) / 6.0) + 1;
   13   1          if (zone < 1) zone = 1;
   14   1          if (zone > 60) zone = 60;
   15   1          return zone;
   16   1      }
   17          
   18          struct UTM latlon2utm(struct Point _p) 
   19          {
   20   1          double _a = 6378137.0;              // WGS84椭球长半轴
   21   1          double _f = 1.0 / 298.257223563;    // WGS84椭球扁率
   22   1          double k0 = 0.9996;                 // UTM投影标准纵缩比
   23   1          double lon0, _x0, _y0, _e, _e2, _n, _t, _c, _A, _M;   //下划线命名，避免字母与寄存器重名
   24   1          int zone;
   25   1          struct UTM utm;
   26   1          
   27   1          zone = get_zone(_p.lon);
   28   1          lon0 = (zone - 1) * 6 - 180 + 3;
   29   1          _x0 = 500000.0;
   30   1          _y0 = _p.lat >= 0 ? 0 : 10000000.0;
   31   1      
   32   1          _e = sqrt(_f * (2 - _f));
   33   1          _e2 = _e * _e;                                                              //此处使用，8051U的TPFU硬
             -件三角函数加速
   34   1          _n = _a / sqrt(1 - _e2 * sin(rad(_p.lat)) * sin(rad(_p.lat)));
   35   1          _t = tan(rad(_p.lat)) * tan(rad(_p.lat));
   36   1          _c = _e2 * cos(rad(_p.lat)) * cos(rad(_p.lat));
   37   1          _A = cos(rad(_p.lat)) * (rad(_p.lon) - rad(lon0));
   38   1          _M = _a * ((1 - _e2 / 4 - 3 * _e2 * _e2 / 64 - 5 * _e2 * _e2 * _e2 / 256) * rad(_p.lat)
   39   1                  - (3 * _e2 / 8 + 3 * _e2 * _e2 / 32 + 45 * _e2 * _e2 * _e2 / 1024) * sin(2 * rad(_p.lat))
   40   1                  + (15 * _e2 * _e2 / 256 + 45 * _e2 * _e2 * _e2 / 1024) * sin(4 * rad(_p.lat))
   41   1                  - (35 * _e2 * _e2 * _e2 / 3072) * sin(6 * rad(_p.lat)));
   42   1      
   43   1      
   44   1          utm.zone = zone;
   45   1          utm.ux = k0 * _n * (_A + (1 - _t + _c) * _A * _A * _A / 6
   46   1                           + (5 - 18 * _t + _t * _t + 72 * _c - 58 * _e2) * _A * _A * _A * _A * _A / 120)
   47   1                  + _x0;
   48   1          utm.uy = k0 * (_M + _n * tan(rad(_p.lat)) * (_A * _A / 2
   49   1                    + (5 - _t + 9 * _c + 4 * _c * _c) * _A * _A * _A * _A / 24
   50   1                    + (61 - 58 * _t + _t * _t + 600 * _c - 330 * _e2) * _A * _A * _A * _A * _A * _A / 720));
   51   1      
   52   1          if (_p.lat < 0) {
   53   2              utm.uy += 10000000.0;
   54   2          }
   55   1      
C251 COMPILER V5.60.0,  LQ_UTM                                                             18/11/25  13:07:52  PAGE 2   

   56   1          return utm;
   57   1      }
   58          
   59          
   60          
   61          
   62          /*  UTM坐标转换简单测试 */
   63          void Test_UTM(void) 
   64          {
   65   1          struct Point p1 = {39.908722, 116.397499};   // 天安门广场  手动给个坐标，感兴趣的可以自己实时读取
   66   1          struct UTM utm1 = latlon2utm(p1);
   67   1          printf("UTM坐标(带号%d):%.8f, %.8f\n", utm1.zone, utm1.ux, utm1.uy);
   68   1          OLED_CLS();
   69   1          OLED_P8x16Str(5, 0,"Test_UTM"); // 将txt中 内容显示出来
   70   1          
   71   1          while(1)
   72   1          {
   73   2              LED_Ctrl(LED0,RVS);
   74   2              delay_ms(100);
   75   2          }
   76   1      }
   77          
   78          
   79          
   80          
*** WARNING C183 IN LINE 20 OF ..\lq_libraries\LQ_LIB\Src\LQ_UTM.c: dead assignment eliminated
*** WARNING C183 IN LINE 21 OF ..\lq_libraries\LQ_LIB\Src\LQ_UTM.c: dead assignment eliminated
*** WARNING C183 IN LINE 22 OF ..\lq_libraries\LQ_LIB\Src\LQ_UTM.c: dead assignment eliminated
*** WARNING C183 IN LINE 29 OF ..\lq_libraries\LQ_LIB\Src\LQ_UTM.c: dead assignment eliminated
*** WARNING C183 IN LINE 30 OF ..\lq_libraries\LQ_LIB\Src\LQ_UTM.c: dead assignment eliminated


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3166     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------        150
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        53     ------
End of Module Information.


C251 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
