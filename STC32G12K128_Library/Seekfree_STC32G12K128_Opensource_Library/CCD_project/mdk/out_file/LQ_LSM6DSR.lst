C251 COMPILER V5.60.0,  LQ_LSM6DSR                                                         18/11/25  13:07:49  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE LQ_LSM6DSR
OBJECT MODULE PLACED IN .\out_file\LQ_LSM6DSR.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\lq_libraries\LQ_LIB\Src\LQ_LSM6DSR.c LARGE NOALIAS FLOAT64 WARNINGLEVEL
                    -(3) OPTIMIZE(SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..
                    -\libraries\zf_driver;..\user;..\code;..\Hardware;..\lq_libraries\LQ_LIB\Inc;..\lq_libraries\Include;..\lq_libraries\Driv
                    -er\Inc) DEBUG PRINT(.\out_file\LQ_LSM6DSR.lst) OBJECT(.\out_file\LQ_LSM6DSR.obj) 

stmt  level    source

    1          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
    2           ¡¾Æ½    Ì¨¡¿±±¾©ÁúÇñÖÇÄÜ¿Æ¼¼STC32Î»ºËÐÄ°å
    3           ¡¾±à    Ð´¡¿ÁúÇñ¿Æ¼¼
    4           ¡¾E-mail  ¡¿chiusir@163.com
    5           ¡¾Èí¼þ°æ±¾¡¿V1.0 °æÈ¨ËùÓÐ£¬µ¥Î»Ê¹ÓÃÇëÏÈÁªÏµÊÚÈ¨
    6           ¡¾Ïà¹ØÐÅÏ¢²Î¿¼ÏÂÁÐµØÖ·¡¿
    7           ¡¾Íø    Õ¾¡¿http://www.lqist.cn
    8           ¡¾ÌÔ±¦µêÆÌ¡¿http://longqiu.taobao.com
    9           --------------------------------------------------------------------------------
   10           ¡¾  IDE  ¡¿ keil C251 V5.60
   11           ¡¾Target ¡¿ STC32G/STC8051U/AI8051U 32Î»Ä£Ê½
   12           ¡¾SYS CLK¡¿ 42 MHzÊ¹ÓÃÄÚ²¿¾§Õñ
   13          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   14          #include "include.h"
   15          
   16          #include "LQ_LSM6DSR.h"
   17          
   18          bit LSM60D_9AGM_FLAG = 0; // ÊÇ·ñ¶ÁÈ¡3ÖáµØ´Å£¬Ä¬ÈÏ0£¬½öÊ¹ÓÃ6Öá²»¶Á£¬¼´LSM60DSR£¬1Îª9Öá·½Ê½ÐèÒª¶ÁÈ¡
   19          
   20          unsigned char LQ_IIC_LSM60DSR_GetID(unsigned char dev, unsigned char reg)
   21          {
   22   1          unsigned char ID[1];
   23   1      #ifdef USE_SOFT_I2C
                   IIC_ReadMultByteFromSlave(dev, reg, 1, ID);
               #else
   26   1          Hard_I2C_ReadNbyte(dev, reg, ID, 1); // Ó²¼þIIC¶ÁÈ¡Ò»¸ö×Ö½Ú
   27   1      #endif
   28   1          return ID[0];
   29   1      }
   30          
   31          void LQ_IIC_LSM60DSR_Init(void)
   32          {
   33   1      #ifdef USE_SOFT_I2C
                   IIC_WriteByteToSlave(LSM6DSR_ADDR, LSM6DSR_CTRL1_XL, 0X20);       // ¼ÓËÙ¶È¼Æ52HZ£¨ÇãÐ±½Ç¼ì²â¹¦ÄÜ¹¤×÷
             -ÔÚ26HZ£¬Òò´Ë¼ÓËÙ¶È¼ÆODR±ØÐëÉèÖÃÎª>=26hz£©,2gÁ¿³Ì¡£
                   IIC_WriteByteToSlave(LSM6DSR_ADDR, LSM6DSR_CTRL9_XL, 0X38);       // Ê¹ÄÜ¼ÓËÙ¶È¼Æx,y,zÖá
                   IIC_WriteByteToSlave(LSM6DSR_ADDR, LSM6DSR_CTRL6_C, 0X40 | 0x10); // ÍÓÂÝÒÇµçÆ½´¥·¢£¬¼ÓËÙ¶È¼Æ¸ßÐÔÄÜÊ¹
             -ÄÜ
                   IIC_WriteByteToSlave(LSM6DSR_ADDR, LSM6DSR_CTRL7_G, 0X80);        // ÍÓÂÝÒÇ¸ßÐÔÄÜÊ¹ÄÜ
                   IIC_WriteByteToSlave(LSM6DSR_ADDR, LSM6DSR_INT2_CTRL, 0X03);      // ¼ÓËÙ¶È¼ÆINT2Òý½ÅÊ§ÄÜ,ÍÓÂÝÒÇÊý¾ÝI
             -NT2Ê¹ÄÜ
                   IIC_WriteByteToSlave(LSM6DSR_ADDR, LSM6DSR_CTRL2_G, 0X1C);        // ÍÓÂÝÒÇ12.5hz  2000dps
                   IIC_WriteByteToSlave(LSM6DSR_ADDR, LSM6DSR_CTRL10_C, 0X38);       // Ê¹ÄÜÍÓÂÝÒÇx,y,zÖá
               #else
   42   1          Hard_I2C_WriteNbyte(LSM6DSR_ADDR, LSM6DSR_CTRL1_XL, 0X20, 1);         // ¼ÓËÙ¶È¼Æ52HZ£¨ÇãÐ±½Ç¼ì²â¹¦ÄÜ
             -¹¤×÷ÔÚ26HZ£¬Òò´Ë¼ÓËÙ¶È¼ÆODR±ØÐëÉèÖÃÎª>=26hz£©,2gÁ¿³Ì¡£
   43   1          Hard_I2C_WriteNbyte(LSM6DSR_ADDR, LSM6DSR_CTRL9_XL, 0X38, 1);         // Ê¹ÄÜ¼ÓËÙ¶È¼Æx,y,zÖá
   44   1          Hard_I2C_WriteNbyte(LSM6DSR_ADDR, LSM6DSR_CTRL6_C, (0X40 | 0x10), 2); // ÍÓÂÝÒÇµçÆ½´¥·¢£¬¼ÓËÙ¶È¼Æ¸ßÐÔ
             -ÄÜÊ¹ÄÜ
   45   1          Hard_I2C_WriteNbyte(LSM6DSR_ADDR, LSM6DSR_CTRL7_G, 0X80, 1);          // ÍÓÂÝÒÇ¸ßÐÔÄÜÊ¹ÄÜ
   46   1          Hard_I2C_WriteNbyte(LSM6DSR_ADDR, LSM6DSR_INT2_CTRL, 0X03, 1);        // ¼ÓËÙ¶È¼ÆINT2Òý½ÅÊ§ÄÜ,ÍÓÂÝÒÇÊ
             -ý¾ÝINT2Ê¹ÄÜ
   47   1          Hard_I2C_WriteNbyte(LSM6DSR_ADDR, LSM6DSR_CTRL2_G, 0X1C, 1);          // ÍÓÂÝÒÇ12.5hz  2000dps
   48   1          Hard_I2C_WriteNbyte(LSM6DSR_ADDR, LSM6DSR_CTRL10_C, 0X38, 1);         // Ê¹ÄÜÍÓÂÝÒÇx,y,zÖá
   49   1      #endif
   50   1          //    //WAKE_UP INTERRUPT Configuration
C251 COMPILER V5.60.0,  LQ_LSM6DSR                                                         18/11/25  13:07:49  PAGE 2   

   51   1          //    MPU_Write_Byte(LSM6DSR_ADDR, LSM6DSR_CTRL1_XL,0x60);
   52   1          //    MPU_Write_Byte(TAP_CFG,0x90);
   53   1          //    MPU_Write_Byte(WAKE_UP_DUR,0x00);
   54   1          //    MPU_Write_Byte(WAKE_UP_THS,0x02);
   55   1          //    MPU_Write_Byte(MD1_CFG,0x20);
   56   1          //    //6D Orientation Configuration
   57   1          //    MPU_Write_Byte(TAP_THS_6D,0x40);
   58   1          //    MPU_Write_Byte(CTRL8_XL,0x01);
   59   1      }
   60          
   61          void LQ_IIC_LSM60DSR_Read(signed short *ax, signed short *ay, signed short *az, signed short *gx, signed 
             -short *gy, signed short *gz)
   62          {
   63   1          unsigned char buf[12];
   64   1      #ifdef USE_SOFT_I2C
                   IIC_ReadMultByteFromSlave(LSM6DSR_ADDR, LSM6DSR_OUTX_L_GYRO, 12, buf);
               #else
   67   1          Hard_I2C_ReadNbyte(LSM6DSR_ADDR, LSM6DSR_OUTX_L_GYRO, buf, 12); // Ó²¼þIIC¶ÁÈ¡Ò»¸ö×Ö½Ú
   68   1      #endif
   69   1          *gx = ((uint16)buf[1] << 8) | buf[0];
   70   1          *gy = ((uint16)buf[3] << 8) | buf[2];
   71   1          *gz = ((uint16)buf[5] << 8) | buf[4];
   72   1          *ax = ((uint16)buf[7] << 8) | buf[6];
   73   1          *ay = ((uint16)buf[9] << 8) | buf[8];
   74   1          *az = ((uint16)buf[11] << 8) | buf[10];
   75   1      }
   76          
   77          void Test_I2C_LQLSM6DSR(void)
   78          {
   79   1          signed short acc_X, acc_Y, acc_Z;
   80   1          signed short gyro_X, gyro_Y, gyro_Z;
   81   1          // signed short mag_X, mag_Y, mag_Z;
   82   1          unsigned char res;
   83   1          char txt[24];
   84   1      
   85   1      #ifdef USE_SOFT_I2C
                   Soft_I2C_Init(); // IIC³õÊ¼»¯//IIC³õÊ¼»¯
               //    delay_ms(100);
               #else
   89   1          Hard_IIC_Init(0); // IIC³õÊ¼»¯
   90   1      #endif
   91   1      
   92   1          OLED_Init(); // LCD³õÊ¼»¯
   93   1          delay_ms(100);
   94   1          OLED_CLS(); // LCDÇåÆÁ
   95   1      
   96   1          /*¶ÁÈ¡Éè±¸ID*/
   97   1          res = LQ_IIC_LSM60DSR_GetID(LSM6DSR_ADDR, WHO_AM_LSM6D);
   98   1      
   99   1          if (res == DRV_ID_LSM6D)
  100   1          {
  101   2              OLED_P8x16Str(0, 0, "LQ6DSR Test"); // ×Ö·û´®ÏÔÊ¾
  102   2          }
  103   1          else {
  104   2              OLED_P8x16Str(0, 0, "get ID error"); // ×Ö·û´®ÏÔÊ¾
  105   2          }
  106   1      
  107   1          sprintf(txt, " 0X%2X", res);
  108   1          OLED_P6x8Str(74, 6, "ID:"); // ÏÔÊ¾×Ö·û´®
  109   1          OLED_P6x8Str(88, 7, txt);   // ÏÔÊ¾×Ö·û´®
  110   1      
  111   1          LQ_IIC_LSM60DSR_Init();
  112   1          while (1)
  113   1          {
  114   2              LQ_IIC_LSM60DSR_Read(&acc_X, &acc_Y, &acc_Z, &gyro_X, &gyro_Y, &gyro_Z);
  115   2              /*ÆÁÄ»ÏÔÊ¾Ñ¡Ôñ*/
C251 COMPILER V5.60.0,  LQ_LSM6DSR                                                         18/11/25  13:07:49  PAGE 3   

  116   2      
  117   2              sprintf((char *)txt, "ax:%06d", acc_X);
  118   2              OLED_P6x8Str(0, 2, txt);
  119   2              sprintf((char *)txt, "ay:%06d", acc_Y);
  120   2              OLED_P6x8Str(0, 3, txt);
  121   2              sprintf((char *)txt, "az:%06d", acc_Z);
  122   2              OLED_P6x8Str(0, 4, txt);
  123   2              sprintf((char *)txt, "gx:%06d", gyro_X);
  124   2              OLED_P6x8Str(0, 5, txt);
  125   2              sprintf((char *)txt, "gy:%06d", gyro_Y);
  126   2              OLED_P6x8Str(0, 6, txt);
  127   2              sprintf((char *)txt, "gz:%06d", gyro_Z);
  128   2              OLED_P6x8Str(0, 7, txt);
  129   2      
  130   2              delay_ms(50);
  131   2          }
  132   1      }
  133          
  134          /********************************************************************************************************
             -*****************************
  135           *                                                       ÒÔÏÂÎªSPIÍ¨ÐÅÄ£Ê½   ÉÐÎ´Íê³É24-11-22
  136           * ******************************************************************************************************
             -******************************/
  137          
  138          unsigned char LQ_SPI_LSM60DSR_GetID(unsigned char reg)
  139          {
  140   1          unsigned char buff;
  141   1      
  142   1      #ifdef USE_SOFT_SPI
  143   1          LQ_SPI_Read(reg, 1, &buff);
  144   1      #else
                   SPI_Read_NByte((reg | 0x80), &buff, 1);
               #endif
  147   1          return buff;
  148   1      }
  149          
  150          // Ïò¼Ä´æÆ÷ÖÐ¶ÁÐ´Êý¾Ý
  151          void SPI_Write_reg(u8 reg, u8 dat)
  152          {
  153   1      #ifdef USE_SOFT_SPI
  154   1          LQ_SPI_Write(reg, dat);
  155   1      #else
                   SPI_WriteByte(reg);
                   SPI_WriteByte(dat);
               #endif
  159   1      }
  160          
  161          // ´Ó¼Ä´æÆ÷ÖÐ¶ÁÈ¡Êý¾Ý
  162          uint8_t SPI_Read_reg(u8 reg)
  163          {
  164   1          u8 buff;
  165   1      
  166   1      #ifdef USE_SOFT_SPI
  167   1          LQ_SPI_Read(reg, 1, &buff);
  168   1      #else
                   SPI_Read_NByte((reg | 0x80), &buff, 1);
               #endif
  171   1          return buff;
  172   1      }
  173          
  174          // ´Ó¼Ä´æÆ÷ÖÐ¶ÁÈ¡Êý¾Ý
  175          void SPI_Read_buf(u8 reg, u8 *buf, u8 len)
  176          {
  177   1      #ifdef USE_SOFT_SPI
  178   1          LQ_SPI_Read(reg, len, buf);
  179   1      #else
C251 COMPILER V5.60.0,  LQ_LSM6DSR                                                         18/11/25  13:07:49  PAGE 4   

                   SPI_Read_NByte((reg | 0x80), buf, len);
               #endif
  182   1      }
  183          
  184          // 9ÖáÍÓÂÝÒÇµØ´Å¼ÆµÄ¼Ä´æÆ÷Ð´Êý¾Ý
  185          uint8_t SPI_Mag_Write_Reg(uint8_t addr, uint8_t dat)
  186          {
  187   1          uint32_t count = 0;
  188   1          SPI_Write_reg(0x17, 0x00);
  189   1          SPI_Write_reg(0x15, 0x38);
  190   1          SPI_Write_reg(0x16, addr);
  191   1          SPI_Write_reg(0x21, dat);
  192   1          SPI_Write_reg(0x14, 0x4c);
  193   1      
  194   1          while ((SPI_Read_reg(0x22) & 0x80) == 0) // ´Ë´¦×ö¼ì²éÊÇ·ñÐ´¶¯×÷Íê³É
  195   1          {
  196   2              if (1000 < count++)
  197   2              {
  198   3                  return 1;
  199   3              }
  200   2              delay_us(100);
  201   2          }
  202   1          return 0;
  203   1      }
  204          
  205          // ´Ó9ÖáÍÓÂÝÒÇµØ´Å¼ÆµÄ¼Ä´æÆ÷¶ÁÊý¾Ý
  206          uint8_t SPI_Mag_Read_Reg(uint8_t addr)
  207          {
  208   1          uint16_t count = 0;
  209   1          SPI_Write_reg(0x17, 0x01);
  210   1          SPI_Write_reg(0x15, 0x39);
  211   1          SPI_Write_reg(0x16, addr);
  212   1          SPI_Write_reg(0x14, 0x4c);
  213   1          while ((SPI_Read_reg(0x22) & 0x01) == 0) // ´Ë´¦×ö¼ì²éÊÇ·ñ¶Á¶¯×÷Íê³É
  214   1          {
  215   2              if (1000 < count++)
  216   2              {
  217   3                  break;
  218   3              }
  219   2              delay_us(100);
  220   2          }
  221   1          return SPI_Read_reg(0x02); // 6DSRµÄ»º³åÊý¾ÝÇøµØÖ·£¬ÓÃÓÚ´æ·Å¹ÒÔØµÄ3ÖáµØ´Å
  222   1      }
  223          
  224          // 6ÖáÍÓÂÝÒÇLSM6DSRºÍ¾ÅÖáÍÓÂÝÒÇLQ9AGMVµÄ¼ì²â
  225          uint8_t Gyro_LSM6DSR_LQ9AGMV_Check(void)
  226          {
  227   1          uint8_t res, i;
  228   1          SPI_Write_reg(LSM6DSR_FUNC_CFG, 0x00); // ÇÐ»»LSM6D¼Ä´æÆ÷À´Á¬½Ó¹ÒÔØµÄ3ÖáµØ´Å
  229   1          //    SPI_Write_reg(LSM6DSR_CTRL3_C, 0x01);
  230   1          //    delay_ms(2);
  231   1          //    SPI_Write_reg(LSM6DSR_FUNC_CFG,0x00);
  232   1      
  233   1          res = LQ_SPI_LSM60DSR_GetID(WHO_AM_LSM6D);
  234   1      
  235   1          if (res == DRV_ID_LSM6D)
  236   1          {
  237   2              for (i = 0; i <= 3; i++)
  238   2              {
  239   3                  SPI_Write_reg(0x14, 0x80);
  240   3                  delay_ms(5);
  241   3                  SPI_Write_reg(0x14, 0x00);
  242   3                  delay_ms(5);
  243   3                  SPI_Write_reg(LSM6DSR_CTRL1_XL, 0X20);
  244   3                  SPI_Write_reg(LSM6DSR_FUNC_CFG, 0x40); // ÇÐ»»µ½¹ÒÔØ×ÜÏß¶ÁÈ¡3ÖáµØ´Å
  245   3                  if (SPI_Mag_Read_Reg(0x0f) == Mag_ID)
C251 COMPILER V5.60.0,  LQ_LSM6DSR                                                         18/11/25  13:07:49  PAGE 5   

  246   3                  {
  247   4                      res = Mag_ID;         // ÈôÄÜ¶Áµ½3ÖáµØ´ÅID£¬ÔòÎª9AGM£¬·ñÔò¿ÉÊÓÎª6ÖáµÄLSM6D
  248   4                      LSM60D_9AGM_FLAG = 1; // ±êÖ¾1£¬Îª9ÖáÄ£Ê½
  249   4                      break;                // ¶Áµ½ºó£¬ÍË³öÑ­»·
  250   4                  }
  251   3              }
  252   2              SPI_Write_reg(LSM6DSR_FUNC_CFG, 0x00);
  253   2          }
  254   1      
  255   1          return res;
  256   1      }
  257          
  258          void LQ_SPI_LSM60DSR_Init(void)
  259          {
  260   1          u8 res;
  261   1          uint16_t count = 0;
  262   1      #ifdef USE_SOFT_SPI
  263   1          Soft_SPI_Init(); // Èí¼þSPI³õÊ¼»¯
  264   1      #else                // Ê¹ÓÃÓ²¼þSPI·½Ê½
                   HSPI_Init();
               #endif
  267   1      
  268   1          SPI_Write_reg(LSM6DSR_CTRL1_XL, 0X20);       // ¼ÓËÙ¶È¼Æ52HZ£¨ÇãÐ±½Ç¼ì²â¹¦ÄÜ¹¤×÷ÔÚ26HZ£¬Òò´Ë¼ÓËÙ¶È¼ÆO
             -DR±ØÐëÉèÖÃÎª>=26hz£©,2gÁ¿³Ì¡£
  269   1          SPI_Write_reg(LSM6DSR_CTRL9_XL, 0X38);       // Ê¹ÄÜ¼ÓËÙ¶È¼Æx,y,zÖá
  270   1          SPI_Write_reg(LSM6DSR_CTRL6_C, 0X40 | 0x10); // ÍÓÂÝÒÇµçÆ½´¥·¢£¬¼ÓËÙ¶È¼Æ¸ßÐÔÄÜÊ¹ÄÜ
  271   1          SPI_Write_reg(LSM6DSR_CTRL7_G, 0X80);        // ÍÓÂÝÒÇ¸ßÐÔÄÜÊ¹ÄÜ
  272   1          SPI_Write_reg(LSM6DSR_INT2_CTRL, 0X03);      // ¼ÓËÙ¶È¼ÆINT2Òý½ÅÊ§ÄÜ,ÍÓÂÝÒÇÊý¾ÝINT2Ê¹ÄÜ
  273   1          SPI_Write_reg(LSM6DSR_CTRL2_G, 0X1C);        // ÍÓÂÝÒÇ12.5hz  2000dps
  274   1          SPI_Write_reg(LSM6DSR_CTRL10_C, 0X38);       // Ê¹ÄÜÍÓÂÝÒÇx,y,zÖá
  275   1      
  276   1          delay_ms(5);
  277   1          res = Gyro_LSM6DSR_LQ9AGMV_Check();
  278   1          if (res == DRV_ID_LSM6D)
  279   1          {
  280   2              //        OLED_P8x16Str(0,0,"LQ6DSR Test");// ×Ö·û´®ÏÔÊ¾
  281   2          }
  282   1          else if (res == Mag_ID)
  283   1          {
  284   2              // ------------------------ ³õÊ¼»¯3ÖáµØ´Å --------------------------
  285   2              SPI_Write_reg(LSM6DSR_FUNC_CFG, 0x40);
  286   2              SPI_Write_reg(0x14, 0x80);
  287   2              delay_ms(2);
  288   2              SPI_Write_reg(0x14, 0x00);
  289   2              delay_ms(2);
  290   2              SPI_Mag_Write_Reg(0x21, 0x04); // ÍÓÂÝÒÇ¸´Î»
  291   2              delay_ms(5);
  292   2              SPI_Mag_Write_Reg(0x21, 0x00);
  293   2              delay_ms(5);
  294   2              SPI_Mag_Write_Reg(0x20, 0x7f);
  295   2              SPI_Mag_Write_Reg(0x23, 0x0c);
  296   2              SPI_Mag_Write_Reg(0x22, 0x00);
  297   2              SPI_Mag_Write_Reg(0x24, 0x00);
  298   2              SPI_Mag_Write_Reg(0x30, 0x02);
  299   2              SPI_Write_reg(0x17, 0x06);
  300   2              SPI_Write_reg(0x15, 0x39);
  301   2              SPI_Write_reg(0x16, 0x28);
  302   2              SPI_Write_reg(0x14, 0x4c);
  303   2      
  304   2              //        while((SPI_Read_reg(0x22) & 0x01) == 0)
  305   2              //        {
  306   2              //            if(1000 < count++){
  307   2              //                break;
  308   2              //            }
  309   2              //            delay_us(100);
  310   2              //        }
C251 COMPILER V5.60.0,  LQ_LSM6DSR                                                         18/11/25  13:07:49  PAGE 6   

  311   2              SPI_Write_reg(0x14, 0x6c);
  312   2              SPI_Write_reg(LSM6DSR_FUNC_CFG, 0x00);
  313   2              //    OLED_P8x16Str(0,0,"LQ9AGM Test");// ×Ö·û´®ÏÔÊ¾
  314   2          }
  315   1      }
  316          
  317          // ¶ÁÈ¡6ÖáÍÓÂÝÒÇÊý¾Ý
  318          void LQ_SPI_LSM60DSR_Read(signed short *ax, signed short *ay, signed short *az, signed short *gx, signed 
             -short *gy, signed short *gz)
  319          {
  320   1          unsigned char buf[12];
  321   1      
  322   1          SPI_Read_buf(LSM6DSR_OUTX_L_GYRO, buf, 12);
  323   1      
  324   1          *gx = ((uint16)buf[1] << 8) | buf[0];
  325   1          *gy = ((uint16)buf[3] << 8) | buf[2];
  326   1          *gz = ((uint16)buf[5] << 8) | buf[4];
  327   1          *ax = ((uint16)buf[7] << 8) | buf[6];
  328   1          *ay = ((uint16)buf[9] << 8) | buf[8];
  329   1          *az = ((uint16)buf[11] << 8) | buf[10];
  330   1      }
  331          
  332          // ¶ÁÈ¡9ÖáÍÓÂÝÒÇLQ9AGMVµÄ3Öá´ÅÁ¦¼Æ
  333          void Get_Mag_data(signed short *magx, signed short *magy, signed short *magz)
  334          {
  335   1          unsigned char buf[6];
  336   1          SPI_Write_reg(LSM6DSR_FUNC_CFG, 0x40);
  337   1          SPI_Read_buf(0x02, buf, 6);
  338   1          *magx = ((signed)(uint16_t)buf[1] << 8) | buf[0];
  339   1          *magy = ((signed)(uint16_t)buf[3] << 8) | buf[2];
  340   1          *magz = ((signed)(uint16_t)buf[5] << 8) | buf[4];
  341   1          SPI_Write_reg(LSM6DSR_FUNC_CFG, 0x00);
  342   1      }
  343          
  344          void Test_SPI_LQLSM6DSR()
  345          {
  346   1          signed short acc_X, acc_Y, acc_Z;
  347   1          signed short gyro_X, gyro_Y, gyro_Z;
  348   1      //    signed short mag_X, mag_Y, mag_Z;
  349   1          unsigned char res;
  350   1          char txt[30];
  351   1      
  352   1          LQ_SPI_LSM60DSR_Init(); // º¯ÊýÄÚÅÐ¶ÏÈí¼þ»¹ÊÇÓ²¼þSPI
  353   1          OLED_Init();            // LCD³õÊ¼»¯
  354   1          delay_ms(100);
  355   1          OLED_CLS(); // LCDÇåÆÁ
  356   1          /*¶ÁÈ¡Éè±¸ID   ÆÁÄ»ÏÔÊ¾Ñ¡Ôñ */
  357   1          //   res = LQ_SPI_LSM60DSR_GetID(WHO_AM_LSM6D);   //º¯ÊýÄÚÅÐ¶ÏÈí¼þ»¹ÊÇÓ²¼þSPI
  358   1          res = Gyro_LSM6DSR_LQ9AGMV_Check();
  359   1          if (res == DRV_ID_LSM6D)
  360   1          {
  361   2              OLED_P8x16Str(0, 0, "LQ6DSR Test"); // ×Ö·û´®ÏÔÊ¾
  362   2          }
  363   1          else if (res == Mag_ID)
  364   1          {
  365   2              OLED_P8x16Str(0, 0, "LQ9AGM Test"); // ×Ö·û´®ÏÔÊ¾
  366   2          }
  367   1           else{
  368   2              OLED_P8x16Str(0, 0, "get ID error"); // ×Ö·û´®ÏÔÊ¾
  369   2          }
  370   1      
  371   1          sprintf(txt, " 0X%2X", res);
  372   1          OLED_P6x8Str(74, 6, "ID:"); // ÏÔÊ¾×Ö·û´®
  373   1          OLED_P6x8Str(88, 7, txt);   // ÏÔÊ¾×Ö·û´®
  374   1      
  375   1          while (1)
C251 COMPILER V5.60.0,  LQ_LSM6DSR                                                         18/11/25  13:07:49  PAGE 7   

  376   1          {
  377   2              LQ_SPI_LSM60DSR_Read(&acc_X, &acc_Y, &acc_Z, &gyro_X, &gyro_Y, &gyro_Z);
  378   2      
  379   2              sprintf((char *)txt, "ax:%06d", acc_X);
  380   2              OLED_P6x8Str(0, 2, txt);
  381   2              sprintf((char *)txt, "ay:%06d", acc_Y);
  382   2              OLED_P6x8Str(0, 3, txt);
  383   2              sprintf((char *)txt, "az:%06d", acc_Z);
  384   2              OLED_P6x8Str(0, 4, txt);
  385   2              sprintf((char *)txt, "gx:%06d", gyro_X);
  386   2              OLED_P6x8Str(0, 5, txt);
  387   2              sprintf((char *)txt, "gy:%06d", gyro_Y);
  388   2              OLED_P6x8Str(0, 6, txt);
  389   2              sprintf((char *)txt, "gz:%06d", gyro_Z);
  390   2              OLED_P6x8Str(0, 7, txt);
  391   2      
  392   2      //        if (LSM60D_9AGM_FLAG) // 9ÖáÄ£Ê½ÏÂ¶ÁÈ¡µØ´ÅÊý¾Ý
  393   2      //        {
  394   2      //            Get_Mag_data(&mag_X, &mag_Y, &mag_Z);
  395   2      
  396   2      //            sprintf((char *)txt, "mx:%06d", mag_X);
  397   2      //            OLED_P6x8Str(64, 2, txt);
  398   2      //            sprintf((char *)txt, "my:%06d", mag_Y);
  399   2      //            OLED_P6x8Str(64, 3, txt);
  400   2      //            sprintf((char *)txt, "mz:%06d", mag_Z);
  401   2      //            OLED_P6x8Str(64, 4, txt);
  402   2      //        }
  403   2      
  404   2              LED_Ctrl(LED0, RVS); // µçÆ½·­×ª,LEDÉÁË¸
  405   2              delay_ms(5);
  406   2          }
  407   1      }
*** WARNING C183 IN LINE 261 OF ..\lq_libraries\LQ_LIB\Src\LQ_LSM6DSR.c: dead assignment eliminated


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2210     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------        163
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        96     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
