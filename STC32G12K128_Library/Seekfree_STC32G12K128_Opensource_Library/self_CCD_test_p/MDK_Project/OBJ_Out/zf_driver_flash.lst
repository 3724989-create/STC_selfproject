C251 COMPILER V5.60.0,  zf_driver_flash                                                    18/11/25  13:39:19  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_driver_flash
OBJECT MODULE PLACED IN .\OBJ_Out\zf_driver_flash.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\..\Libraries\zf_driver\zf_driver_flash.c XSMALL OPTIMIZE(6,SPEED) REGFI
                    -LE(.\OBJ_Out\LQ_STCAI32_LIB.ORC) BROWSE INCDIR(..\..\libraries\Driver;..\..\libraries\Driver\Inc;..\..\libraries\Include
                    -;..\..\libraries\LQ_LIB\Inc;..\User;..\code;..\Hardware;..\..\libraries\zf_common;..\..\Libraries\zf_components;..\..\Li
                    -braries\zf_device;..\..\Libraries\zf_driver) DEFINE(STC32G) DEBUG PRINT(.\OBJ_Out\zf_driver_flash.lst) OBJECT(.\OBJ_Out\
                    -zf_driver_flash.obj) 

stmt  level    source

    1          ///******************************************************************************************************
             -***************
    2          //* CH32V307VCT6 Opensourec Library ¼´£¨CH32V307VCT6 ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈı·½¿ªÔ´¿â
    3          //* Copyright (c) 2022 SEEKFREE Öğ·É¿Æ¼¼
    4          //*
    5          //* ±¾ÎÄ¼şÊÇCH32V307VCT6 ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          //*
    7          //* CH32V307VCT6 ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼ş
    8          //* Äú¿ÉÒÔ¸ù¾İ×ÔÓÉÈí¼ş»ù½ğ»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ğí¿ÉÖ¤£©µÄÌõ¿î
    9          //* ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØĞÂ·¢²¼ºÍ/»òĞŞ¸ÄËü
   10          //*
   11          //* ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          //* ÉõÖÁÃ»ÓĞÒşº¬µÄÊÊÏúĞÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          //* ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          //*
   15          //* ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·İ GPL µÄ¸±±¾
   16          //* Èç¹ûÃ»ÓĞ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          //*
   18          //* ¶îÍâ×¢Ã÷£º
   19          //* ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ğí¿ÉÖ¤Ğ­Òé ÒÔÉÏĞí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          //* Ğí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼ş¼ĞÏÂµÄ GPL3_permission_statement.txt ÎÄ¼şÖĞ
   21          //* Ğí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼ş¼ĞÏÂ ¼´¸ÃÎÄ¼ş¼ĞÏÂµÄ LICENSE ÎÄ¼ş
   22          //* »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌĞò µ«ĞŞ¸ÄÄÚÈİÊ±±ØĞë±£ÁôÖğ·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          //*
   24          //* ÎÄ¼şÃû³Æ          zf_driver_flash
   25          //* ¹«Ë¾Ãû³Æ          ³É¶¼Öğ·É¿Æ¼¼ÓĞÏŞ¹«Ë¾
   26          //* °æ±¾ĞÅÏ¢          ²é¿´ libraries/doc ÎÄ¼ş¼ĞÄÚ version ÎÄ¼ş °æ±¾ËµÃ÷
   27          //* ¿ª·¢»·¾³          MounRiver Studio V1.8.1
   28          //* ÊÊÓÃÆ½Ì¨          CH32V307VCT6
   29          //* µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          //*
   31          //* ĞŞ¸Ä¼ÇÂ¼
   32          //* ÈÕÆÚ                                      ×÷Õß                             ±¸×¢
   33          //* 2022-09-15        ´óW            first version
   34          //*******************************************************************************************************
             -*************/
   35          
   36          
   37          
   38          //#include "zf_common_debug.h"
   39          //#include "zf_common_interrupt.h"
   40          //#include "zf_common_clock.h"
   41          
   42          //#include "zf_driver_flash.h"
   43          
   44          //flash_data_union flash_union_buffer[FLASH_DATA_BUFFER_SIZE];               // FLASH ²Ù×÷µÄÊı¾İ»º³åÇø
   45          
   46          ////-----------------------------------------------------------------------------------------------------
             ---------------
   47          //// º¯Êı¼ò½é     Ğ£Ñé FLASH ÊÇ·ñÓĞÊı¾İ
   48          //// ²ÎÊıËµÃ÷     sector_num      ĞèÒªĞ´ÈëµÄÉÈÇø±àºÅ ²ÎÊı·¶Î§ <0 - 63>
   49          //// ²ÎÊıËµÃ÷     page_num        µ±Ç°ÉÈÇøÒ³µÄ±àºÅ   ²ÎÊı·¶Î§ <0 - 3>
   50          //// ·µ»Ø²ÎÊı     uint8           1-ÓĞÊı¾İ 0-Ã»ÓĞÊı¾İ Èç¹ûĞèÒª¶ÔÓĞÊı¾İµÄÇøÓòĞ´ÈëĞÂµÄÊı¾İÔòÓ¦¸Ã¶ÔËùÔÚÉÈÇø½
             -øĞĞ²Á³ı²Ù×÷
   51          //// Ê¹ÓÃÊ¾Àı     flash_check(63, 3);
C251 COMPILER V5.60.0,  zf_driver_flash                                                    18/11/25  13:39:19  PAGE 2   

   52          //// ±¸×¢ĞÅÏ¢
   53          ////-----------------------------------------------------------------------------------------------------
             ---------------
   54          //uint8 flash_check (uint32 sector_num, uint32 page_num)
   55          //{
   56          //    //zf_assert(sector_num <= FLASH_MAX_SECTION_INDEX);                                                
             -   // ²ÎÊı·¶Î§ 0-63
   57          //    //zf_assert(page_num <= FLASH_MAX_PAGE_INDEX);                                                     
             -   // ²ÎÊı·¶Î§ 0-3
   58          
   59          //    uint8  return_state = 0;
   60          //    uint16 temp_loop;
   61          //    uint32 flash_addr = ((FLASH_BASE_ADDR+FLASH_SECTION_SIZE*sector_num+FLASH_PAGE_SIZE*page_num));    
             - // ÌáÈ¡µ±Ç° Flash µØÖ·
   62          
   63          //      interrupt_global_disable();
   64          
   65          //    //clock_reset();                                  // ¸´Î»Ê±ÖÓ
   66          //    //clock_set_freq(SYSTEM_CLOCK_120M);          // ÉèÖÃÏµÍ³ÆµÂÊÎª120Mhz
   67          
   68          //    for(temp_loop = 0; temp_loop < FLASH_PAGE_SIZE; temp_loop+=4)                                      
             - // Ñ­»·¶ÁÈ¡ Flash µÄÖµ
   69          //    {
   70          //        if( (*(__IO u32*) (flash_addr+temp_loop)) != 0xFFFFFFFF )                                      
             - // ¸Ãµ¥Æ¬»ú²Á³ıºóÈç¹û²»ÊÇ 0xE339E339 ÄÇ¾ÍÊÇÓĞÖµ
   71          //        {
   72          //            return_state = 1;
   73          //            break;
   74          //        }
   75          //    }
   76          
   77          //    //clock_reset();                                  // ¸´Î»Ê±ÖÓ
   78          //    //clock_set_freq(system_clock);       // ÉèÖÃ»ØÔ­À´µÄÏµÍ³ÆµÂÊ
   79          //    interrupt_global_enable();
   80          
   81          //    return return_state;
   82          //}
   83          
   84          ////-----------------------------------------------------------------------------------------------------
             ---------------
   85          //// º¯Êı¼ò½é     ²Á³ıÒ»¸öÉÈÇøÊı¾İ(4KB)
   86          //// ²ÎÊıËµÃ÷     sector_num      ĞèÒªĞ´ÈëµÄÉÈÇø±àºÅ ²ÎÊı·¶Î§ <0 - 63>
   87          //// ²ÎÊıËµÃ÷     page_num        µ±Ç°ÉÈÇøÒ³µÄ±àºÅ   ²ÎÊı·¶Î§ <0 - 3>
   88          //// ·µ»Ø²ÎÊı     uint8           1-±íÊ¾Ê§°Ü 0-±íÊ¾³É¹¦
   89          //// Ê¹ÓÃÊ¾Àı     flash_erase_page(63, 3);
   90          //// ±¸×¢ĞÅÏ¢
   91          ////          ±ê×¼²Á³ıÖ»ÄÜÊÇ²ÁÒ»¸öÉÈÇøµÄÊı¾İ£¬4KB×Ö½Ú³¤¶È
   92          ////-----------------------------------------------------------------------------------------------------
             ---------------
   93          //uint8 flash_erase_sector (uint32 sector_num, uint32 page_num)
   94          //{
   95          //    //zf_assert(sector_num <= FLASH_MAX_SECTION_INDEX);                                                
             -   // ²ÎÊı·¶Î§ 0-63
   96          //    //zf_assert(page_num <= FLASH_MAX_PAGE_INDEX);                                                     
             -   // ²ÎÊı·¶Î§ 0-3
   97          
   98          //    uint8 return_state = 0;
   99          
  100          //    static volatile FLASH_Status gFlashStatus = FLASH_COMPLETE;
  101          //    uint32 flash_addr = ((FLASH_BASE_ADDR+FLASH_SECTION_SIZE*sector_num+FLASH_PAGE_SIZE*page_num));    
             - // ÌáÈ¡µ±Ç° Flash µØÖ·
  102          
  103          //    uint32 primask = interrupt_global_disable();
  104          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  105          //    //clock_set_freq(SYSTEM_CLOCK_120M);          // ÉèÖÃÏµÍ³ÆµÂÊÎª120Mhz
  106          
C251 COMPILER V5.60.0,  zf_driver_flash                                                    18/11/25  13:39:19  PAGE 3   

  107          //    FLASH_Unlock();                                                                                    
             - // ½âËø Flash
  108          //    FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);                          
             - // Çå³ı²Ù×÷±êÖ¾
  109          //    gFlashStatus = FLASH_ErasePage(flash_addr);                                                        
             - // ²Á³ı
  110          //    FLASH_ClearFlag(FLASH_FLAG_EOP );                                                                  
             - // Çå³ş²Ù×÷±êÖ¾
  111          //    FLASH_Lock();                                                                                      
             - // Ëø¶¨ Flash
  112          //    if(gFlashStatus != FLASH_COMPLETE)          // ÅĞ¶Ï²Ù×÷ÊÇ·ñ³É¹¦
  113          //    {
  114          //        return_state = 1;
  115          //    }
  116          
  117          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  118          //    //clock_set_freq(system_clock);       // ÉèÖÃ»ØÔ­À´µÄÏµÍ³ÆµÂÊ
  119          //    interrupt_global_enable(primask);
  120          //    return return_state;
  121          //}
  122          
  123          ////-----------------------------------------------------------------------------------------------------
             ---------------
  124          //// º¯Êı¼ò½é     ¶ÁÈ¡Ò»Ò³
  125          //// ²ÎÊıËµÃ÷     sector_num      ĞèÒªĞ´ÈëµÄÉÈÇø±àºÅ ²ÎÊı·¶Î§ <0 - 63>
  126          //// ²ÎÊıËµÃ÷     page_num        µ±Ç°ÉÈÇøÒ³µÄ±àºÅ   ²ÎÊı·¶Î§ <0 - 3>
  127          //// ²ÎÊıËµÃ÷     buf             ĞèÒª¶ÁÈ¡µÄÊı¾İµØÖ·   ´«ÈëµÄÊı×éÀàĞÍ±ØĞëÎªuint32
  128          //// ²ÎÊıËµÃ÷     len             ĞèÒªĞ´ÈëµÄÊı¾İ³¤¶È   ²ÎÊı·¶Î§ 1-256
  129          //// ·µ»Ø²ÎÊı     void
  130          //// Ê¹ÓÃÊ¾Àı     flash_read_page(63, 3, data_buffer, 256);
  131          //// ±¸×¢ĞÅÏ¢
  132          ////-----------------------------------------------------------------------------------------------------
             ---------------
  133          //void flash_read_page (uint32 sector_num, uint32 page_num, uint32 *buf, uint16 len)
  134          //{
  135          //    //zf_assert(sector_num <= FLASH_MAX_SECTION_INDEX);                                                
             -   // ²ÎÊı·¶Î§ 0-63
  136          //    //zf_assert(page_num <= FLASH_MAX_PAGE_INDEX);                                                     
             -   // ²ÎÊı·¶Î§ 0-3
  137          //    //zf_assert(len <= FLASH_DATA_BUFFER_SIZE);
  138          
  139          //    uint16 temp_loop = 0;
  140          //    uint32 flash_addr = 0;
  141          //    flash_addr = ((FLASH_BASE_ADDR+FLASH_SECTION_SIZE*sector_num+FLASH_PAGE_SIZE*page_num));           
             - // ÌáÈ¡µ±Ç° Flash µØÖ·
  142          
  143          //    uint32 primask = interrupt_global_disable();
  144          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  145          //    //clock_set_freq(SYSTEM_CLOCK_120M);          // ÉèÖÃÏµÍ³ÆµÂÊÎª120Mhz
  146          
  147          
  148          //    for(temp_loop = 0; temp_loop < len; temp_loop++)                                                   
             - // ¸ù¾İÖ¸¶¨³¤¶È¶ÁÈ¡
  149          //    {
  150          //        *buf++ = *(__IO uint32*)(flash_addr+temp_loop*4);                                              
             - // Ñ­»·¶ÁÈ¡ Flash µÄÖµ
  151          //    }
  152          //                                                                                       // Ëø¶¨ Flash
  153          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  154          //    //clock_set_freq(system_clock);       // ÉèÖÃ»ØÔ­À´µÄÏµÍ³ÆµÂÊ
  155          //    interrupt_global_enable(primask);
  156          //}
  157          
  158          ////-----------------------------------------------------------------------------------------------------
             ---------------
  159          //// º¯Êı¼ò½é     ±à³ÌÒ»Ò³
C251 COMPILER V5.60.0,  zf_driver_flash                                                    18/11/25  13:39:19  PAGE 4   

  160          //// ²ÎÊıËµÃ÷     sector_num      ĞèÒªĞ´ÈëµÄÉÈÇø±àºÅ ²ÎÊı·¶Î§ <0 - 63>
  161          //// ²ÎÊıËµÃ÷     page_num        µ±Ç°ÉÈÇøÒ³µÄ±àºÅ   ²ÎÊı·¶Î§ <0 - 3>
  162          //// ²ÎÊıËµÃ÷     buf             ĞèÒªĞ´ÈëµÄÊı¾İµØÖ·   ´«ÈëµÄÊı×éÀàĞÍ±ØĞëÎª uint32
  163          //// ²ÎÊıËµÃ÷     len             ĞèÒªĞ´ÈëµÄÊı¾İ³¤¶È   ²ÎÊı·¶Î§ 1-256
  164          //// ·µ»Ø²ÎÊı     uint8           1-±íÊ¾Ê§°Ü 0-±íÊ¾³É¹¦
  165          //// Ê¹ÓÃÊ¾Àı     flash_write_page(63, 3, data_buffer, 256);
  166          //// ±¸×¢ĞÅÏ¢
  167          ////-----------------------------------------------------------------------------------------------------
             ---------------
  168          //uint8 flash_write_page (uint32 sector_num, uint32 page_num, const uint32 *buf, uint16 len)
  169          //{
  170          //    //zf_assert(sector_num <= FLASH_MAX_SECTION_INDEX);                                                
             -   // ²ÎÊı·¶Î§ 0-63
  171          //    //zf_assert(page_num <= FLASH_MAX_PAGE_INDEX);                                                     
             -   // ²ÎÊı·¶Î§ 0-3
  172          //    //zf_assert(len <= FLASH_DATA_BUFFER_SIZE);
  173          //    uint8 return_state = 0;
  174          //    static volatile FLASH_Status gFlashStatus = FLASH_COMPLETE;
  175          //    uint32 flash_addr = 0;
  176          //    flash_addr = ((FLASH_BASE_ADDR+FLASH_SECTION_SIZE*sector_num+FLASH_PAGE_SIZE*page_num));           
             - // ÌáÈ¡µ±Ç° Flash µØÖ·
  177          
  178          //    if(flash_check(sector_num, page_num))                                                              
             - // ÅĞ¶ÏÊÇ·ñÓĞÊı¾İ ÕâÀïÊÇÈßÓàµÄ±£»¤ ·ÀÖ¹ÓĞÈËÃ»²Á³ı¾ÍĞ´Èë
  179          //    {
  180          //        flash_erase_sector(sector_num, page_num);                                                      
             - // ²Á³ıÕâÒ»ÉÈÇø
  181          //    }
  182          
  183          //    uint32 primask = interrupt_global_disable();
  184          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  185          //    //clock_set_freq(SYSTEM_CLOCK_120M);          // ÉèÖÃÏµÍ³ÆµÂÊÎª120Mhz
  186          //    FLASH_Unlock();                                                                                    
             - // ½âËø Flash
  187          //    while(len--)                                                                                       
             - // ¸ù¾İ³¤¶È
  188          //    {
  189          //        gFlashStatus = FLASH_ProgramWord(flash_addr, *buf++);                                          
             - // °´×Ö 32bit Ğ´ÈëÊı¾İ
  190          //        if(gFlashStatus != FLASH_COMPLETE)                                                             
             - // ·´¸´È·ÈÏ²Ù×÷ÊÇ·ñ³É¹¦
  191          //        {
  192          //            return_state = 1;
  193          //            break;
  194          //        }
  195          //        flash_addr += 4;                                                                               
             - // µØÖ·×ÔÔö
  196          //    }
  197          //    FLASH_Lock();                                                                                      
             - // Ëø¶¨ Flash
  198          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  199          //    //clock_set_freq(system_clock);       // ÉèÖÃ»ØÔ­À´µÄÏµÍ³ÆµÂÊ
  200          //    interrupt_global_enable(primask);
  201          
  202          //    return return_state;
  203          //}
  204          
  205          
  206          ////-----------------------------------------------------------------------------------------------------
             ---------------
  207          //// º¯Êı¼ò½é     ´ÓÖ¸¶¨ FLASH µÄÉÈÇøµÄÖ¸¶¨Ò³Âë¶ÁÈ¡Êı¾İµ½»º³åÇø
  208          //// ²ÎÊıËµÃ÷     sector_num      ĞèÒªĞ´ÈëµÄÉÈÇø±àºÅ ²ÎÊı·¶Î§ <0 - 63>
  209          //// ²ÎÊıËµÃ÷     page_num        µ±Ç°ÉÈÇøÒ³µÄ±àºÅ   ²ÎÊı·¶Î§ <0 - 3>
  210          //// ·µ»Ø²ÎÊı     void
  211          //// Ê¹ÓÃÊ¾Àı     flash_read_page_to_buffer(63, 3);
  212          //// ±¸×¢ĞÅÏ¢
C251 COMPILER V5.60.0,  zf_driver_flash                                                    18/11/25  13:39:19  PAGE 5   

  213          ////-----------------------------------------------------------------------------------------------------
             ---------------
  214          //void flash_read_page_to_buffer (uint32 sector_num, uint32 page_num)
  215          //{
  216          //    //zf_assert(sector_num <= FLASH_MAX_SECTION_INDEX);                                                
             -   // ²ÎÊı·¶Î§ 0-63
  217          //    //zf_assert(page_num <= FLASH_MAX_PAGE_INDEX);                                                     
             -   // ²ÎÊı·¶Î§ 0-3
  218          //    uint16 temp_loop;
  219          //    uint32 flash_addr = ((FLASH_BASE_ADDR + FLASH_SECTION_SIZE*sector_num + FLASH_PAGE_SIZE*page_num));
             - // ÌáÈ¡µ±Ç° Flash µØÖ·
  220          
  221          
  222          
  223          //    for(temp_loop = 0; temp_loop < FLASH_DATA_BUFFER_SIZE; temp_loop++)                                
             - // ¸ù¾İÖ¸¶¨³¤¶È¶ÁÈ¡
  224          //    {
  225          //        flash_union_buffer[temp_loop].uint32_type = *(__IO uint32*)(flash_addr+temp_loop*4);           
             - // Ñ­»·¶ÁÈ¡ Flash µÄÖµ
  226          //    }
  227          
  228          
  229          //}
  230          
  231          ////-----------------------------------------------------------------------------------------------------
             ---------------
  232          //// º¯Êı¼ò½é     ÏòÖ¸¶¨ FLASH µÄÉÈÇøµÄÖ¸¶¨Ò³ÂëĞ´Èë»º³åÇøµÄÊı¾İ
  233          //// ²ÎÊıËµÃ÷     sector_num      ĞèÒªĞ´ÈëµÄÉÈÇø±àºÅ ²ÎÊı·¶Î§ <0 - 63>
  234          //// ²ÎÊıËµÃ÷     page_num        µ±Ç°ÉÈÇøÒ³µÄ±àºÅ   ²ÎÊı·¶Î§ <0 - 3>
  235          //// ·µ»Ø²ÎÊı     uint8           1-±íÊ¾Ê§°Ü 0-±íÊ¾³É¹¦
  236          //// Ê¹ÓÃÊ¾Àı     flash_write_page_from_buffer(63, 3);
  237          //// ±¸×¢ĞÅÏ¢
  238          ////-----------------------------------------------------------------------------------------------------
             ---------------
  239          //uint8 flash_write_page_from_buffer (uint32 sector_num, uint32 page_num)
  240          //{
  241          //    //zf_assert(sector_num <= FLASH_MAX_SECTION_INDEX);                                                
             -   // ²ÎÊı·¶Î§ 0-63
  242          //    //zf_assert(page_num <= FLASH_MAX_PAGE_INDEX);                                                     
             -   // ²ÎÊı·¶Î§ 0-3
  243          //    uint8 return_state = 0;
  244          
  245          //    static volatile FLASH_Status gFlashStatus = FLASH_COMPLETE;
  246          //    uint32 flash_addr = 0;
  247          //    uint16 len = 0;
  248          //    flash_addr = ((FLASH_BASE_ADDR+FLASH_SECTION_SIZE*sector_num+FLASH_PAGE_SIZE*page_num));           
             - // ÌáÈ¡µ±Ç° Flash µØÖ·
  249          
  250          //    if(flash_check(sector_num, page_num))                                                              
             - // ÅĞ¶ÏÊÇ·ñÓĞÊı¾İ ÕâÀïÊÇÈßÓàµÄ±£»¤ ·ÀÖ¹ÓĞÈËÃ»²Á³ı¾ÍĞ´Èë
  251          //        flash_erase_sector(sector_num, page_num);                                                      
             - // ²Á³ıÕâÒ»Ò³
  252          
  253          //    uint32 primask = interrupt_global_disable();
  254          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  255          //    //clock_set_freq(SYSTEM_CLOCK_120M);          // ÉèÖÃÏµÍ³ÆµÂÊÎª120Mhz
  256          
  257          //    FLASH_Unlock();                                                                                    
             - // ½âËø Flash
  258          //    while(len < FLASH_DATA_BUFFER_SIZE)                                                                
             - // ¸ù¾İ³¤¶È
  259          //    {
  260          //        gFlashStatus = FLASH_ProgramWord(flash_addr, flash_union_buffer[len].uint32_type);             
             - // °´×Ö 32bit Ğ´ÈëÊı¾İ
  261          //        if(gFlashStatus != FLASH_COMPLETE)                                                             
             - // ·´¸´È·ÈÏ²Ù×÷ÊÇ·ñ³É¹¦
C251 COMPILER V5.60.0,  zf_driver_flash                                                    18/11/25  13:39:19  PAGE 6   

  262          //        {
  263          //            return_state = 1;
  264          //            break;
  265          //        }
  266          
  267          //        len++;                                                                                         
             - // ³¤¶È×ÔÔö
  268          //        flash_addr += 4;                                                                               
             - // µØÖ·×ÔÔö
  269          //    }
  270          //    FLASH_Lock();                                                                                      
             - // Ëø¶¨ Flash
  271          
  272          //    //clock_reset();                      // ¸´Î»Ê±ÖÓ
  273          //    //clock_set_freq(system_clock);       // ÉèÖÃ»ØÔ­À´µÄÏµÍ³ÆµÂÊ
  274          //    interrupt_global_enable(primask);
  275          
  276          //    return return_state;
  277          //}
  278          
  279          
  280          ////-----------------------------------------------------------------------------------------------------
             ---------------
  281          //// º¯Êı¼ò½é     Çå¿ÕÊı¾İ»º³åÇø
  282          //// ²ÎÊıËµÃ÷     void
  283          //// ·µ»Ø²ÎÊı     void
  284          //// Ê¹ÓÃÊ¾Àı     flash_buffer_clear();
  285          //// ±¸×¢ĞÅÏ¢
  286          ////-----------------------------------------------------------------------------------------------------
             ---------------
  287          //void flash_buffer_clear (void)
  288          //{
  289          //    memset(flash_union_buffer, 0xFF, FLASH_PAGE_SIZE);
  290          //}
  291          
*** WARNING C38 IN LINE 291 OF ..\..\Libraries\zf_driver\zf_driver_flash.c: empty translation unit


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
