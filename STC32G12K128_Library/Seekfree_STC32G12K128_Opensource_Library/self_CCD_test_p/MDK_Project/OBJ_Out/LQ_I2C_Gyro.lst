C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE LQ_I2C_Gyro
OBJECT MODULE PLACED IN .\OBJ_Out\LQ_I2C_Gyro.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\..\libraries\LQ_LIB\Src\LQ_I2C_Gyro.c XSMALL OPTIMIZE(6,SPEED) REGFILE(
                    -.\OBJ_Out\LQ_STCAI32_LIB.ORC) BROWSE INCDIR(..\..\libraries\Driver;..\..\libraries\Driver\Inc;..\..\libraries\Include;..
                    -\..\libraries\LQ_LIB\Inc;..\User;..\code;..\Hardware;..\..\libraries\zf_common;..\..\Libraries\zf_components;..\..\Libra
                    -ries\zf_device;..\..\Libraries\zf_driver) DEFINE(STC32G) DEBUG PRINT(.\OBJ_Out\LQ_I2C_Gyro.lst) OBJECT(.\OBJ_Out\LQ_I2C_
                    -Gyro.obj) 

stmt  level    source

    1          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
    2           ¡¾Æ½    Ì¨¡¿±±¾©ÁúÇñÖÇÄÜ¿Æ¼¼STC32Î»ºËÐÄ°å
    3           ¡¾±à    Ð´¡¿ÁúÇñ¿Æ¼¼
    4           ¡¾E-mail  ¡¿chiusir@163.com
    5           ¡¾Èí¼þ°æ±¾¡¿V1.0 °æÈ¨ËùÓÐ£¬µ¥Î»Ê¹ÓÃÇëÏÈÁªÏµÊÚÈ¨
    6           ¡¾Ïà¹ØÐÅÏ¢²Î¿¼ÏÂÁÐµØÖ·¡¿
    7           ¡¾Íø    Õ¾¡¿http://www.lqist.cn
    8           ¡¾ÌÔ±¦µêÆÌ¡¿http://longqiu.taobao.com
    9           --------------------------------------------------------------------------------
   10           ¡¾  IDE  ¡¿ keil C251 V5.60
   11           ¡¾Target ¡¿ STC32G/STC8051U/AI8051U 32Î»Ä£Ê½
   12           ¡¾SYS CLK¡¿ 42 MHzÊ¹ÓÃÄÚ²¿¾§Õñ
   13          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   14          
   15          #include "LQ_I2C_Gyro.h"
   16          
   17          signed short aac_x, aac_y, aac_z;    // ¼ÓËÙ¶È´«¸ÐÆ÷Ô­Ê¼Êý¾Ý
   18          signed short gyro_x, gyro_y, gyro_z; // ÍÓÂÝÒÇÔ­Ê¼Êý¾Ý
   19          
   20          #define MPU6050_ADDR 0x68 // IICÐ´ÈëÊ±µÄµØÖ·×Ö½ÚÊý¾Ý£¬+1Îª¶ÁÈ¡
   21          
   22          unsigned char IIC_ICM20602 = 0;
   23          unsigned char IIC_ICM20689 = 0;
   24          unsigned char IIC_MPU9250 = 0;
   25          unsigned char IIC_ICM42605 = 0;
   26          unsigned char IIC_MPU6050 = 0;
   27          unsigned char IIC_errorid = 0;
   28          
   29          unsigned char Gyro_ID = 0;
   30          
   31          /**
   32           * @brief   ¶ÁÈ¡ÍÓÂÝÒÇµÄÉè±¸ID
   33           *
   34           * @param   void
   35           *
   36           * @retur   void
   37           *
   38           * @note
   39           *
   40           * @see      Gyro_Chose();
   41           *
   42           * @date     2021/7/12 ÐÇÆÚÒ»
   43           */
   44          unsigned char Gyro_Chose(void)
   45          {
   46   1        Gyro_ID = MPU_Read_Byte(MPU6050_ADDR, WHO_AM_I);
   47   1        switch (Gyro_ID)
   48   1        {
   49   2        case 0x12:
   50   2          IIC_ICM20602 = 1;
   51   2          break;
   52   2        case 0x71:
   53   2          IIC_MPU9250 = 1;
   54   2          break;
   55   2        case 0x98:
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 2   

   56   2          IIC_ICM20689 = 1;
   57   2          break;
   58   2        case 0x42:
   59   2          IIC_ICM42605 = 1;
   60   2          break;
   61   2        case 0x68:
   62   2          IIC_MPU6050 = 1;
   63   2          break;
   64   2        default:
   65   2          IIC_errorid = 1;
   66   2          return 0;
   67   2        }
   68   1        return Gyro_ID;
   69   1      }
   70          
   71          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
   72           ¡¾º¯ÊýÃû¡¿void Test_IIC_Gyro(void)
   73           ¡¾¹¦  ÄÜ¡¿²âÊÔÍÓÂÝÒÇÄ£¿é
   74           ¡¾²ÎÊýÖµ¡¿ÎÞ
   75           ¡¾·µ»ØÖµ¡¿ÎÞ
   76           ¡¾×÷  Õß¡¿LQ Guo
   77           ¡¾×îºó¸üÐÂ¡¿2022Äê11ÔÂ6ÈÕ
   78           ¡¾Èí¼þ°æ±¾¡¿V1.82
   79           ¡¾µ÷ÓÃÑùÀý¡¿ Test_IIC_Gyro();
   80             ¼ì²âÍÓÂÝÒÇ¼ÓËÙ¶È¼ÆÄ£¿é
   81             ÐÍºÅ£º6050 20602 20689 9250 42605£¨AD0½ÓGND£©×Ô¶¯Ê¶±ð
   82           IIC½Ó¿Ú SCK-B10 SDA-B11
   83           QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   84          void Test_I2C_Gyro(void)
   85          {
   86   1        unsigned char res;
   87   1        char txt[30];
   88   1        signed short aacx, aacy, aacz;    // ¼ÓËÙ¶È´«¸ÐÆ÷Ô­Ê¼Êý¾Ý
   89   1        signed short gyrox, gyroy, gyroz; // ÍÓÂÝÒÇÔ­Ê¼Êý¾Ý
   90   1        short magx, magy, magz;           // µØ´ÅÔ­Ê¼Êý¾Ý
   91   1      
   92   1        Soft_I2C_Init(); // IIC³õÊ¼»¯//IIC³õÊ¼»¯
   93   1        delay_ms(100);
   94   1        res = Gyro_Chose(); // ÅÐ¶ÏÍÓÂÝÒÇÐÍºÅ
   95   1        sprintf(txt, "ID:0X%2x", res);
   96   1      
   97   1        OLED_Init(); // LCD³õÊ¼»¯
   98   1        delay_ms(100);
   99   1        OLED_CLS();               // LCDÇåÆÁ
  100   1        OLED_P6x8Str(70, 2, txt); // ×Ö·û´®ÏÔÊ¾
  101   1        if (IIC_ICM20602)
  102   1          OLED_P8x16Str(0, 0, "LQ 20602 Test"); // ×Ö·û´®ÏÔÊ¾
  103   1        if (IIC_MPU6050)
  104   1          OLED_P8x16Str(0, 0, "LQ 6050 Test"); // ×Ö·û´®ÏÔÊ¾
  105   1        if (IIC_ICM42605)
  106   1          OLED_P8x16Str(0, 0, "LQ 42605 Test"); // ×Ö·û´®ÏÔÊ¾
  107   1        if (IIC_MPU9250)
  108   1          OLED_P8x16Str(0, 0, "LQ 9250 Test"); // ×Ö·û´®ÏÔÊ¾
  109   1        if (IIC_ICM20689)
  110   1          OLED_P8x16Str(0, 0, "LQ 20689 Test"); // ×Ö·û´®ÏÔÊ¾
  111   1        if (IIC_errorid)
  112   1        {
  113   2          OLED_P8x16Str(0, 0, "Gyro Test fail"); // ×Ö·û´®ÏÔÊ¾
  114   2      //    while (1)
  115   2      //      ;
  116   2        }
  117   1      
  118   1        MPU6050_Init();
  119   1        while (1)
  120   1        {
  121   2          MPU_Get_Raw_data(&aacx, &aacy, &aacz, &gyrox, &gyroy, &gyroz); // µÃµ½¼ÓËÙ¶È´«¸ÐÆ÷Êý¾Ý
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 3   

  122   2          if (IIC_MPU9250)
  123   2            MPU9250_Get_Magnetometer(&magx, &magy, &magz);
  124   2      
  125   2          sprintf((char *)txt, "ax:%06d", aacx);
  126   2          OLED_P6x8Str(0, 2, txt);
  127   2          sprintf((char *)txt, "ay:%06d", aacy);
  128   2          OLED_P6x8Str(0, 3, txt);
  129   2          sprintf((char *)txt, "az:%06d", aacz);
  130   2          OLED_P6x8Str(0, 4, txt);
  131   2          sprintf((char *)txt, "gx:%06d", gyrox);
  132   2          OLED_P6x8Str(0, 5, txt);
  133   2          sprintf((char *)txt, "gy:%06d", gyroy);
  134   2          OLED_P6x8Str(0, 6, txt);
  135   2          sprintf((char *)txt, "gz:%06d", gyroz);
  136   2          OLED_P6x8Str(0, 7, txt);
  137   2      
  138   2          if (IIC_MPU9250)
  139   2          {
  140   3            sprintf((char *)txt, "gx:%06d", magx);
  141   3            OLED_P6x8Str(70, 5, txt);
  142   3            sprintf((char *)txt, "gy:%06d", magy);
  143   3            OLED_P6x8Str(70, 6, txt);
  144   3            sprintf((char *)txt, "gz:%06d", magz);
  145   3            OLED_P6x8Str(70, 7, txt);
  146   3          }
  147   2      
  148   2          delay_ms(30);
  149   2        }
  150   1      }
  151          
  152          //***************·´ÕýÇÐYÖá½Ç¶È*************************//
  153          /*
  154           * º¯ÊýÃû£ºMpu6050_ACC_angle_X_Z
  155           * ÃèÊö  £º¼ÓËÙ¶È¼Æ·´ÕýÇÐ½Ç¶È
  156           * ÊäÈë  £ºÎÞ
  157           * Êä³ö  £º½Ç¶ÈÖµ
  158           * µ÷ÓÃ  £ºÄÚ²¿µ÷ÓÃ
  159           */
  160          // float Mpu6050_ACC_angle_X_Z(void)
  161          //{
  162          //   Get_AccData();
  163          //   return (atan2f((float)aacz,(float)aacx)*(180.0/3.1415));   //·´ÕýÇÐ¼ÓËÙ¶È¼ÆµÃµ½½Ç¶ÈÖµ
  164          // }
  165          ////**************»ý·ÖYÖá½Ç¶È*************************//
  166          ///*
  167          // * º¯ÊýÃû£ºMpu6050_GYRO_Y_Ang(void)
  168          // * ÃèÊö  £º»ý·ÖYÖá½Ç¶È
  169          // * ÊäÈë  £ºÎÞ
  170          // * Êä³ö  £ºÎÞ
  171          // * µ÷ÓÃ  £ºÄÚ²¿µ÷ÓÃ
  172          // */
  173          // void Mpu6050_GYRO_Y_Ang(void)
  174          //{
  175          //    float
  176          //  Get_Gyro();   //»ñÈ¡YÖáÍÓÂÝÒÇÖµ
  177          //  GYRO_Speed_Y= (float)((GYRO_Y)*0.00032); //×ª»»ÏµÊý0.00018²¨ÐÎÕý³£   0.00015
  178          //  GYRO_Ang_Y+=GYRO_Speed_Y;  //»ý·Ö½Ç¶È
  179          //}
  180          ////***************¼ÓËÙ¶È¼ÆºÍÍÓÂÝÒÇÊý¾ÝÈÚºÏ*****************************//
  181          // void Mpu6050_GYRO_ACCEL_Ang_Y()
  182          //{
  183          //   Mpu6050_GYRO_Y_Ang();
  184          //   ACCEL_Ang_Y=Mpu6050_ACC_angle_X_Z();
  185          //   temp_p=(ACCEL_Ang_Y-GYRO_Ang_Y)*0.025;//ÈÚºÏÏµÊý  //0.025
  186          //   GYRO_Ang_Y=GYRO_Ang_Y+temp_p;
  187          //   ACC_GYRO_Ang_Y=GYRO_Ang_Y;
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 4   

  188          // }
  189          /**
  190           * @brief    ³õÊ¼»¯MPU6050 »òÕß ICM20602
  191           *
  192           * @param    ÎÞ
  193           *
  194           * @return   0£º³õÊ¼»¯³É¹¦   1£ºÊ§°Ü
  195           *
  196           * @note     Ê¹ÓÃÇ°ÏÈ³õÊ¼»¯IIC½Ó¿Ú
  197           *
  198           * @see      MPU6050_Init();
  199           *
  200           * @date     2019/6/12 ÐÇÆÚÈý
  201           */
  202          unsigned char MPU6050_Init(void)
  203          {
  204   1        int res;
  205   1        if (IIC_ICM42605)
  206   1        {
  207   2          MPU_Write_Byte(MPU6050_ADDR, device_config_reg,
  208   2                         bit_soft_reset_chip_config); // chip soft reset
  209   2          delay_ms(10);
  210   2      
  211   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x01); // Change to bank 1
  212   2          MPU_Write_Byte(MPU6050_ADDR, intf_config4, 0x03); // 4 wire spi mode  ËÄÏßSPI  Ä¬ÈÏÖµ0x03
  213   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  214   2          MPU_Write_Byte(MPU6050_ADDR, fifo_config_reg, 0x40); // Stream-to-FIFO Mode  ÍÓÂÝÒÇYÖáÏÝ²¨ÂË²¨Æ÷µÄÆµÂ
             -ÊÑ¡Ôñ
  215   2      
  216   2          res = MPU_Read_Byte(MPU6050_ADDR, int_source0_reg);
  217   2          MPU_Write_Byte(MPU6050_ADDR, int_source0_reg, 0x00);
  218   2          MPU_Write_Byte(MPU6050_ADDR, fifo_config2_reg, 0x00); // watermark
  219   2          MPU_Write_Byte(MPU6050_ADDR, fifo_config3_reg, 0x02); // watermark
  220   2          MPU_Write_Byte(MPU6050_ADDR, int_source0_reg, (unsigned char)res);
  221   2          MPU_Write_Byte(MPU6050_ADDR, fifo_config1_reg, 0x63); // Enable the accel and gyro to the FIFO
  222   2      
  223   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  224   2          MPU_Write_Byte(MPU6050_ADDR, int_config_reg, 0x36);
  225   2      
  226   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  227   2          res = (MPU_Read_Byte(MPU6050_ADDR, int_source0_reg) | bit_int_fifo_ths_int1_en);
  228   2          MPU_Write_Byte(MPU6050_ADDR, int_source0_reg, (unsigned char)res);
  229   2      
  230   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  231   2          res = ((MPU_Read_Byte(MPU6050_ADDR, accel_config0_reg) & 0x1F) | (bit_accel_ui_fs_sel_8g)); // 8g
  232   2          MPU_Write_Byte(MPU6050_ADDR, accel_config0_reg, (unsigned char)res);
  233   2      
  234   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  235   2          res = ((MPU_Read_Byte(MPU6050_ADDR, accel_config0_reg) & 0xF0) | bit_accel_odr_50hz);
  236   2          MPU_Write_Byte(MPU6050_ADDR, accel_config0_reg, (unsigned char)res);
  237   2      
  238   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  239   2          res = ((MPU_Read_Byte(MPU6050_ADDR, gyro_config0_reg) & 0x1F) | (bit_gyro_ui_fs_sel_1000dps));
  240   2          MPU_Write_Byte(MPU6050_ADDR, gyro_config0_reg, (unsigned char)res);
  241   2      
  242   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  243   2          res = ((MPU_Read_Byte(MPU6050_ADDR, gyro_config0_reg) & 0xF0) | bit_gyro_odr_50hz);
  244   2          MPU_Write_Byte(MPU6050_ADDR, gyro_config0_reg, (unsigned char)res);
  245   2      
  246   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  247   2          res = MPU_Read_Byte(MPU6050_ADDR, pwr_mgmt0_reg) | (bit_accel_mode_ln); // Accel on in LNM
  248   2          MPU_Write_Byte(MPU6050_ADDR, pwr_mgmt0_reg, (unsigned char)res);
  249   2          delay_ms(1);
  250   2      
  251   2          MPU_Write_Byte(MPU6050_ADDR, reg_bank_sel, 0x00);
  252   2          res = MPU_Read_Byte(MPU6050_ADDR, pwr_mgmt0_reg) | (bit_gyro_mode_ln); // Gyro on in LNM
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 5   

  253   2          MPU_Write_Byte(MPU6050_ADDR, pwr_mgmt0_reg, (unsigned char)res);
  254   2          delay_ms(1);
  255   2          return 0;
  256   2        }
  257   1        else
  258   1        {
  259   2          res = MPU_Read_Byte(MPU6050_ADDR, WHO_AM_I); // ¶ÁÈ¡MPU6050µÄID
  260   2          if (res != Gyro_ID)                          // Æ÷¼þIDÕýÈ·
  261   2            return 1;
  262   2      
  263   2          res = 0;
  264   2          res += MPU_Write_Byte(MPU6050_ADDR, MPU_PWR_MGMT1_REG, 0X80); // ¸´Î»MPU6050
  265   2          delay_ms(100);                                                // ÑÓÊ±100ms
  266   2          res += MPU_Write_Byte(MPU6050_ADDR, MPU_PWR_MGMT1_REG, 0X00); // »½ÐÑMPU6050
  267   2          res += MPU_Set_Gyro_Fsr(3);                                   // ÍÓÂÝÒÇ´«¸ÐÆ÷,¡À2000dps
  268   2          res += MPU_Set_Accel_Fsr(1);                                  // ¼ÓËÙ¶È´«¸ÐÆ÷,¡À4g
  269   2          res += MPU_Set_Rate(1000);                                    // ÉèÖÃ²ÉÑùÂÊ1000Hz
  270   2          res += MPU_Write_Byte(MPU6050_ADDR, MPU_CFG_REG, 0x02);       // ÉèÖÃÊý×ÖµÍÍ¨ÂË²¨Æ÷   98hz
  271   2          res += MPU_Write_Byte(MPU6050_ADDR, MPU_INT_EN_REG, 0X00);    // ¹Ø±ÕËùÓÐÖÐ¶Ï
  272   2          res += MPU_Write_Byte(MPU6050_ADDR, MPU_USER_CTRL_REG, 0X00); // I2CÖ÷Ä£Ê½¹Ø±Õ
  273   2          res += MPU_Write_Byte(MPU6050_ADDR, MPU_PWR_MGMT1_REG, 0X01); // ÉèÖÃCLKSEL,PLL XÖáÎª²Î¿¼
  274   2          res += MPU_Write_Byte(MPU6050_ADDR, MPU_PWR_MGMT2_REG, 0X00); // ¼ÓËÙ¶ÈÓëÍÓÂÝÒÇ¶¼¹¤×÷
  275   2          if (IIC_MPU9250)
  276   2          {
  277   3            MPU_Write_Byte(MPU6050_ADDR, MPU_FIFO_EN_REG, 0X00);   // ¹Ø±ÕFIFO
  278   3            MPU_Write_Byte(MPU6050_ADDR, MPU_INTBP_CFG_REG, 0X82); // INTÒý½ÅµÍµçÆ½ÓÐÐ§£¬¿ªÆôbypassÄ£Ê½
  279   3            res = MPU_Read_Byte(AK8963_ADDR, MPU_MAG_WIA);         // ¶ÁÈ¡MPU9250µÄID
  280   3            if (res == AK8963_ID)                                  // Æ÷¼þIDÕýÈ·
  281   3            {
  282   4              MPU_Write_Byte(AK8963_ADDR, MPU_MAG_CNTL2_REG, 0X01); // Èí¼þÖØÖÃ
  283   4              delay_ms(100);
  284   4              MPU_Write_Byte(AK8963_ADDR, MPU_MAG_CNTL1_REG, 0X16); // ÉèÖÃÎªµ¥´ÎÄ£Ê½£¬Êä³ö16bit
  285   4            }
  286   3          }
  287   2          return 0;
  288   2        }
  289   1      }
  290          
  291          /**
  292           * @brief    ÉèÖÃÍÓÂÝÒÇ²âÁ¿·¶Î§
  293           *
  294           * @param    fsr:0,¡À250dps;1,¡À500dps;2,¡À1000dps;3,¡À2000dps
  295           *
  296           * @return   0 £ºÉèÖÃ³É¹¦
  297           *
  298           * @note     ÎÞ
  299           *
  300           * @see      MPU_Set_Gyro_Fsr(3);        //ÍÓÂÝÒÇ´«¸ÐÆ÷,¡À2000dps
  301           *
  302           * @date     2019/6/12 ÐÇÆÚÈý
  303           */
  304          unsigned char MPU_Set_Gyro_Fsr(unsigned char fsr)
  305          {
  306   1        return MPU_Write_Byte(MPU6050_ADDR, MPU_GYRO_CFG_REG, fsr << 3);
  307   1      }
  308          
  309          /**
  310           * @brief    ÉèÖÃ¼ÓËÙ¶È¼Æ²âÁ¿·¶Î§
  311           *
  312           * @param    fsr:0,¡À2g;1,¡À4g;2,¡À8g;3,¡À16g
  313           *
  314           * @return   0£ºÉèÖÃ³É¹¦
  315           *
  316           * @note     ÎÞ
  317           *
  318           * @see      MPU_Set_Accel_Fsr(1);       //¼ÓËÙ¶È´«¸ÐÆ÷,¡À4g
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 6   

  319           *
  320           * @date     2019/6/12 ÐÇÆÚÈý
  321           */
  322          unsigned char MPU_Set_Accel_Fsr(unsigned char fsr)
  323          {
  324   1        return MPU_Write_Byte(MPU6050_ADDR, MPU_ACCEL_CFG_REG, fsr << 3);
  325   1      }
  326          
  327          /**
  328           * @brief    ÉèÖÃÊý×ÖµÍÍ¨ÂË²¨
  329           *
  330           * @param    lpf:Êý×ÖµÍÍ¨ÂË²¨ÆµÂÊ(Hz)
  331           *
  332           * @return   0£ºÉèÖÃ³É¹¦
  333           *
  334           * @note     ÎÞ
  335           *
  336           * @see      MPU_Set_LPF(100);
  337           *
  338           * @date     2019/6/12 ÐÇÆÚÈý
  339           */
  340          unsigned char MPU_Set_LPF(uint16 lpf)
  341          {
  342   1        unsigned char dat = 0;
  343   1        if (lpf >= 188)
  344   1          dat = 1;
  345   1        else if (lpf >= 98)
  346   1          dat = 2;
  347   1        else if (lpf >= 42)
  348   1          dat = 3;
  349   1        else if (lpf >= 20)
  350   1          dat = 4;
  351   1        else if (lpf >= 10)
  352   1          dat = 5;
  353   1        else
  354   1          dat = 6;
  355   1        return MPU_Write_Byte(MPU6050_ADDR, MPU_CFG_REG, dat); // ÉèÖÃÊý×ÖµÍÍ¨ÂË²¨Æ÷
  356   1      }
  357          
  358          /**
  359           * @brief    ÉèÖÃ²ÉÑùÂÊ
  360           *
  361           * @param    rate:4~1000(Hz)
  362           *
  363           * @return   0£ºÉèÖÃ³É¹¦
  364           *
  365           * @note     ÎÞ
  366           *
  367           * @see      MPU_Set_Rate(1000);              //ÉèÖÃ²ÉÑùÂÊ1000Hz
  368           *
  369           * @date     2019/6/12 ÐÇÆÚÈý
  370           */
  371          unsigned char MPU_Set_Rate(uint16 rate)
  372          {
  373   1        unsigned char dat;
  374   1        if (rate > 1000)
  375   1          rate = 1000;
  376   1        if (rate < 4)
  377   1          rate = 4;
  378   1        dat = 1000 / rate - 1;
  379   1        MPU_Write_Byte(MPU6050_ADDR, MPU_SAMPLE_RATE_REG, dat); // ÉèÖÃÊý×ÖµÍÍ¨ÂË²¨Æ÷
  380   1        return MPU_Set_LPF(rate / 2);                           // ×Ô¶¯ÉèÖÃLPFÎª²ÉÑùÂÊµÄÒ»°ë
  381   1      }
  382          
  383          /**
  384           * @brief    »ñÈ¡ÎÂ¶ÈÖµ
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 7   

  385           *
  386           * @param    ÎÞ
  387           *
  388           * @return   ÎÂ¶ÈÖµ(À©´óÁË100±¶)
  389           *
  390           * @note     ÎÞ
  391           *
  392           * @see      signed short temp = MPU_Get_Temperature();
  393           *
  394           * @date     2019/6/12 ÐÇÆÚÈý
  395           */
  396          short MPU_Get_Temperature(void)
  397          {
  398   1        unsigned char buf[2];
  399   1        short raw;
  400   1        float temp;
  401   1        MPU_Read_Len(MPU6050_ADDR, MPU_TEMP_OUTH_REG, 2, buf);
  402   1        raw = ((uint16)buf[0] << 8) | buf[1];
  403   1        temp = 21 + ((double)raw) / 333.87;
  404   1        return (short)temp * 100;
  405   1      }
  406          
  407          /**
  408           * @brief    »ñÈ¡´ÅÁ¦¼ÆÖµ
  409           *
  410           * @param    mx,my,mz:´ÅÁ¦¼ÆÒÇx,y,zÖáµÄÔ­Ê¼¶ÁÊý(´ø·ûºÅ)
  411           *
  412           * @return   0£º¶ÁÈ¡³É¹¦
  413           *
  414           * @note     ÎÞ
  415           *
  416           * @see      signed short data[3];
  417           * @see      MPU9250_Get_Magnetometer(&data[0], &data[1], &data[2]);
  418           *
  419           * @date     2020/12/15 ÐÇÆÚ¶þ
  420           */
  421          unsigned char MPU9250_Get_Magnetometer(short *mx, short *my, short *mz)
  422          {
  423   1        unsigned char buf[6], res;
  424   1        res = MPU_Read_Len(AK8963_ADDR, MPU_MAG_XOUTL_REG, 6, buf);
  425   1        if (res == 0)
  426   1        {
  427   2          *mx = ((uint16_t)buf[1] << 8) | buf[0];
  428   2          *my = ((uint16_t)buf[3] << 8) | buf[2];
  429   2          *mz = ((uint16_t)buf[5] << 8) | buf[4];
  430   2        }
  431   1        MPU_Read_Byte(AK8963_ADDR, MPU_MAG_ST2_REG);
  432   1        return res;
  433   1      }
  434          
  435          /**
  436           * @brief    »ñÈ¡ÍÓÂÝÒÇÖµ
  437           *
  438           * @param    gx,gy,gz:ÍÓÂÝÒÇx,y,zÖáµÄÔ­Ê¼¶ÁÊý(´ø·ûºÅ)
  439           *
  440           * @return   0£º¶ÁÈ¡³É¹¦
  441           *
  442           * @note     ÎÞ
  443           *
  444           * @see      signed short data[3];
  445           * @see      MPU_Get_Gyroscope(&data[0], &data[1], &data[2]);
  446           *
  447           * @date     2019/6/12 ÐÇÆÚÈý
  448           */
  449          unsigned char MPU_Get_Gyroscope(signed short *gx, signed short *gy,
  450                                          signed short *gz)
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 8   

  451          {
  452   1        unsigned char buf[6], res;
  453   1        res = MPU_Read_Len(MPU6050_ADDR, MPU_GYRO_XOUTH_REG, 6, buf);
  454   1        if (res == 0)
  455   1        {
  456   2          *gx = ((uint16)buf[0] << 8) | buf[1];
  457   2          *gy = ((uint16)buf[2] << 8) | buf[3];
  458   2          *gz = ((uint16)buf[4] << 8) | buf[5];
  459   2        }
  460   1        return res;
  461   1      }
  462          
  463          /**
  464           * @brief    »ñÈ¡¼ÓËÙ¶ÈÖµ
  465           *
  466           * @param    ax,ay,az:ÍÓÂÝÒÇx,y,zÖáµÄÔ­Ê¼¶ÁÊý(´ø·ûºÅ)
  467           *
  468           * @return   0£º¶ÁÈ¡³É¹¦
  469           *
  470           * @note     ÎÞ
  471           *
  472           * @see      signed short data[3];
  473           * @see      MPU_Get_Accelerometer(&data[0], &data[1], &data[2]);
  474           *
  475           * @date     2019/6/12 ÐÇÆÚÈý
  476           */
  477          unsigned char MPU_Get_Accelerometer(signed short *ax, signed short *ay,
  478                                              signed short *az)
  479          {
  480   1        unsigned char buf[6], res;
  481   1        res = MPU_Read_Len(MPU6050_ADDR, MPU_ACCEL_XOUTH_REG, 6, buf);
  482   1        if (res == 0)
  483   1        {
  484   2          *ax = ((uint16)buf[0] << 8) | buf[1];
  485   2          *ay = ((uint16)buf[2] << 8) | buf[3];
  486   2          *az = ((uint16)buf[4] << 8) | buf[5];
  487   2        }
  488   1        return res;
  489   1      }
  490          
  491          /**
  492           * @brief    »ñÈ¡ ¼ÓËÙ¶ÈÖµ ½ÇËÙ¶ÈÖµ
  493           *
  494           * @param    ax,ay,az:ÍÓÂÝÒÇx,y,zÖáµÄÔ­Ê¼¶ÁÊý(´ø·ûºÅ)
  495           * @param    gx,gy,gz:ÍÓÂÝÒÇx,y,zÖáµÄÔ­Ê¼¶ÁÊý(´ø·ûºÅ)
  496           *
  497           * @return   0£º¶ÁÈ¡³É¹¦
  498           *
  499           * @note     ÎÞ
  500           *
  501           * @see      signed short data[6];
  502           * @see      MPU_Get_Raw_data(&data[0], &data[1], &data[2],&data[3], &data[4], &data[5]);
  503           *
  504           */
  505          unsigned char MPU_Get_Raw_data(signed short *ax, signed short *ay,
  506                                         signed short *az, signed short *gx, signed short *gy, signed short *gz)
  507          {
  508   1        if (IIC_ICM42605)
  509   1        {
  510   2          unsigned char buf[14], res;
  511   2          res = MPU_Read_Len(MPU6050_ADDR, ICM_ACCEL_XOUTH_REG, 12, buf);
  512   2          if (res == 0)
  513   2          {
  514   3            *ax = ((uint16)buf[0] << 8) | buf[1];
  515   3            *ay = ((uint16)buf[2] << 8) | buf[3];
  516   3            *az = ((uint16)buf[4] << 8) | buf[5];
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 9   

  517   3            *gx = ((uint16)buf[6] << 8) | buf[7];
  518   3            *gy = ((uint16)buf[8] << 8) | buf[9];
  519   3            *gz = ((uint16)buf[10] << 8) | buf[11];
  520   3          }
  521   2          return res;
  522   2        }
  523   1        else
  524   1        {
  525   2          unsigned char buf[14], res;
  526   2      
  527   2          res = MPU_Read_Len(MPU6050_ADDR, MPU_ACCEL_XOUTH_REG, 14, buf);
  528   2          if (res == 0)
  529   2          {
  530   3            *ax = ((uint16)buf[0] << 8) | buf[1];
  531   3            *ay = ((uint16)buf[2] << 8) | buf[3];
  532   3            *az = ((uint16)buf[4] << 8) | buf[5];
  533   3            *gx = ((uint16)buf[8] << 8) | buf[9];
  534   3            *gy = ((uint16)buf[10] << 8) | buf[11];
  535   3            *gz = ((uint16)buf[12] << 8) | buf[13];
  536   3          }
  537   2          return res;
  538   2        }
  539   1      }
  540          
  541          /**
  542           * @brief    IIC Á¬Ðø¶Á
  543           *
  544           * @param    addr:Æ÷¼þµØÖ·
  545           * @param    reg :Òª¶ÁÈ¡µÄ¼Ä´æÆ÷µØÖ·
  546           * @param    len :Òª¶ÁÈ¡µÄ³¤¶È
  547           * @param    buf :¶ÁÈ¡µ½µÄÊý¾Ý´æ´¢Çø
  548           *
  549           * @return   0 £º¶ÁÈ¡³É¹¦
  550           *
  551           * @note     µ×²ãÇý¶¯ ÒÆÖ²Ê±ÐèÒªÐÞ¸Ä
  552           *
  553           * @see      unsigned char buf[14];
  554           * @see      MPU_Read_Len(MPU6050_ADDR,MPU_ACCEL_XOUTH_REG,14,buf);
  555           *
  556           * @date     2019/6/12 ÐÇÆÚÈý
  557           */
  558          unsigned char MPU_Read_Len(unsigned char addr, unsigned char reg,
  559                                     unsigned char len, unsigned char *buf)
  560          {
  561   1        return IIC_ReadMultByteFromSlave(addr << 1, reg, len, buf);
  562   1      }
  563          
  564          /**
  565           * @brief    IIC Á¬ÐøÐ´
  566           *
  567           * @param    addr:Æ÷¼þµØÖ·
  568           * @param    reg :ÒªÐ´ÈëµÄ¼Ä´æÆ÷µØÖ·
  569           * @param    len :ÒªÐ´ÈëµÄ³¤¶È
  570           * @param    buf :Ð´Èëµ½µÄÊý¾Ý´æ´¢Çø
  571           *
  572           * @return   0 £ºÐ´Èë³É¹¦
  573           *
  574           * @note     µ×²ãÇý¶¯ ÒÆÖ²Ê±ÐèÒªÐÞ¸Ä
  575           *
  576           * @see      unsigned char buf[14];
  577           * @see      MPU9250_Write_Len(MPU9250_ADDR,MPU_ACCEL_XOUTH_REG,14,buf);
  578           *
  579           * @date     2021/7/1 ÐÇÆÚËÄ
  580           */
  581          unsigned char MPU_Write_Len(unsigned char addr, unsigned char reg,
  582                                      unsigned char len, unsigned char *buf)
C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 10  

  583          {
  584   1        return IIC_WriteMultByteToSlave(addr << 1, reg, len, buf);
  585   1      }
  586          
  587          /**
  588           * @brief    IIC Ð´Ò»¸ö¼Ä´æÆ÷
  589           *
  590           * @param    addr  :Æ÷¼þµØÖ·
  591           * @param    reg   :¼Ä´æÆ÷µØÖ·
  592           * @param    value :ÒªÐ´ÈëµÄÖµ
  593           *
  594           * @return   0 £º¶ÁÈ¡³É¹¦
  595           *
  596           * @note     µ×²ãÇý¶¯ ÒÆÖ²Ê±ÐèÒªÐÞ¸Ä
  597           *
  598           * @see      MPU_Write_Byte(MPU6050_ADDR,MPU_SAMPLE_RATE_REG,1);
  599           *
  600           * @date     2019/6/12 ÐÇÆÚÈý
  601           */
  602          unsigned char MPU_Write_Byte(unsigned char addr, unsigned char reg,
  603                                       unsigned char value)
  604          {
  605   1        return IIC_WriteByteToSlave(addr << 1, reg, value);
  606   1      }
  607          
  608          /**
  609           * @brief    IIC ¶ÁÒ»¸ö¼Ä´æÆ÷
  610           *
  611           * @param    addr  :Æ÷¼þµØÖ·
  612           * @param    reg   :¼Ä´æÆ÷µØÖ·
  613           *
  614           * @return   ¶ÁÈ¡µÄÖµ
  615           *
  616           * @note     µ×²ãÇý¶¯ ÒÆÖ²Ê±ÐèÒªÐÞ¸Ä
  617           *
  618           * @see      MPU_Read_Byte(MPU6050_ADDR,WHO_AM_I);
  619           *
  620           * @date     2019/6/12 ÐÇÆÚÈý
  621           */
  622          unsigned char MPU_Read_Byte(unsigned char addr, unsigned char reg)
  623          {
  624   1        unsigned char value[1];
  625   1        MPU_Read_Len(addr, reg, 1, value);
  626   1        return value[0];
  627   1      }
  628          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2182     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        19        128
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       175     ------
End of Module Information.

C251 COMPILER V5.60.0,  LQ_I2C_Gyro                                                        18/11/25  13:39:10  PAGE 11  


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
