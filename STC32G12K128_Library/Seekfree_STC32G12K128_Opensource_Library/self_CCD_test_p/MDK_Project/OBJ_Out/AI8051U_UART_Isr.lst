C251 COMPILER V5.60.0,  AI8051U_UART_Isr                                                   18/11/25  13:39:14  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE AI8051U_UART_Isr
OBJECT MODULE PLACED IN .\OBJ_Out\AI8051U_UART_Isr.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\..\libraries\Driver\isr\AI8051U_UART_Isr.c XSMALL OPTIMIZE(6,SPEED) REG
                    -FILE(.\OBJ_Out\LQ_STCAI32_LIB.ORC) BROWSE INCDIR(..\..\libraries\Driver;..\..\libraries\Driver\Inc;..\..\libraries\Inclu
                    -de;..\..\libraries\LQ_LIB\Inc;..\User;..\code;..\Hardware;..\..\libraries\zf_common;..\..\Libraries\zf_components;..\..\
                    -Libraries\zf_device;..\..\Libraries\zf_driver) DEFINE(STC32G) DEBUG PRINT(.\OBJ_Out\AI8051U_UART_Isr.lst) OBJECT(.\OBJ_O
                    -ut\AI8051U_UART_Isr.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* ------------------- Web: www.STCAI.com -----------------------------*/
    3          /*---------------------------------------------------------------------*/
    4          
    5          #include "AI8051U_UART.h"
    6          
    7          bit B_ULinRX1_Flag;
    8          bit B_ULinRX2_Flag;
    9          
   10          //========================================================================
   11          // 函数: UART1_ISR_Handler
   12          // 描述: UART1中断函数.
   13          // 参数: none.
   14          // 返回: none.
   15          // 版本: V1.0, 2020-09-23
   16          //========================================================================
   17          #ifdef UART1
   18          void UART1_ISR_Handler (void) interrupt UART1_VECTOR
   19          {
   20   1              u8 Status;
   21   1      
   22   1              if(RI)
   23   1              {
   24   2                      RI = 0;
   25   2      
   26   2                      //--------USART LIN---------------
   27   2                      Status = USARTCR5;
   28   2                      if(Status & 0x02)     //if LIN header is detected
   29   2                      {
   30   3                              B_ULinRX1_Flag = 1;
   31   3                      }
   32   2      
   33   2                      if(Status & 0xc0)     //if LIN break is detected / LIN header error is detected
   34   2                      {
   35   3                              COM1.RX_Cnt = 0;
   36   3                      }
   37   2                      USARTCR5 &= ~0xcb;    //Clear flag
   38   2                      //--------------------------------
   39   2      
   40   2              if(COM1.RX_Cnt >= COM_RX1_Lenth)        COM1.RX_Cnt = 0;
   41   2              RX1_Buffer[COM1.RX_Cnt++] = SBUF;
   42   2              COM1.RX_TimeOut = TimeOutSet1;
   43   2              }
   44   1      
   45   1              if(TI)
   46   1              {
   47   2                      TI = 0;
   48   2      
   49   2              #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
                               if(COM1.TX_send != COM1.TX_write)
                               {
                                       SBUF = TX1_Buffer[COM1.TX_send];
                                       if(++COM1.TX_send >= COM_TX1_Lenth)             COM1.TX_send = 0;
                               }
                               else    COM1.B_TX_busy = 0;
C251 COMPILER V5.60.0,  AI8051U_UART_Isr                                                   18/11/25  13:39:14  PAGE 2   

                       #else
   57   2              COM1.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
   58   2              #endif
   59   2              }
   60   1      }
   61          #endif
   62          
   63          //========================================================================
   64          // 函数: UART2_ISR_Handler
   65          // 描述: UART2中断函数.
   66          // 参数: none.
   67          // 返回: none.
   68          // 版本: V1.0, 2020-09-23
   69          //========================================================================
   70          #ifdef UART2
               void UART2_ISR_Handler (void) interrupt UART2_VECTOR
               {
                       u8 Status;
               
                       if(S2RI)
                       {
                               CLR_RI2();
               
                               //--------USART LIN---------------
                               Status = USART2CR5;
                               if(Status & 0x02)     //if LIN header is detected
                               {
                                       B_ULinRX2_Flag = 1;
                               }
               
                               if(Status & 0xc0)     //if LIN break is detected / LIN header error is detected
                               {
                                       COM2.RX_Cnt = 0;
                               }
                               USART2CR5 &= ~0xcb;   //Clear flag
                               //--------------------------------
               
                       if(COM2.RX_Cnt >= COM_RX2_Lenth)        COM2.RX_Cnt = 0;
                       RX2_Buffer[COM2.RX_Cnt++] = S2BUF;
                       COM2.RX_TimeOut = TimeOutSet2;
                       }
               
                       if(S2TI)
                       {
                               CLR_TI2();
               
                       #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
                               if(COM2.TX_send != COM2.TX_write)
                               {
                                       S2BUF = TX2_Buffer[COM2.TX_send];
                                       if(++COM2.TX_send >= COM_TX2_Lenth)             COM2.TX_send = 0;
                               }
                               else    COM2.B_TX_busy = 0;
                       #else
                       COM2.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
                       #endif
                       }
               }
               #endif
  115          
  116          //========================================================================
  117          // 函数: UART3_ISR_Handler
  118          // 描述: UART3中断函数.
  119          // 参数: none.
  120          // 返回: none.
  121          // 版本: V1.0, 2020-09-23
C251 COMPILER V5.60.0,  AI8051U_UART_Isr                                                   18/11/25  13:39:14  PAGE 3   

  122          //========================================================================
  123          #ifdef UART3
  124          #include "LQ_SBUS.h"
  125          unsigned char sbuff;  //SBUS缓冲
  126          unsigned char num3;
  127          extern unsigned char SReadBuff[64];
  128          
  129          void UART3_ISR_Handler (void) interrupt UART3_VECTOR
  130          {
  131   1              if(S3RI)
  132   1              {
  133   2                      CLR_RI3();
  134   2      
  135   2              if(COM3.RX_Cnt >= COM_RX3_Lenth)        COM3.RX_Cnt = 0;
  136   2      //        RX3_Buffer[COM3.RX_Cnt++] = S3BUF;
  137   2              /* SBUS START 用户代码 */
  138   2              sbuff = (u8)S3BUF;
  139   2              if(sbus_Rec_Fini_Flag == 1)       //可以接收
  140   2              {
  141   3                  if (num3 == 0 && sbuff == 0x0F)   //帧头
  142   3                  {
  143   4                      SReadBuff[num3] = sbuff;
  144   4                      num3++;
  145   4                  }
  146   3                  else if(num3 != 0)
  147   3                  {
  148   4      //                LED_Ctrl(LED0, RVS);        // LED闪烁 指示程序运行状态
  149   4                      SReadBuff[num3] = sbuff;
  150   4                      num3++;
  151   4                      if (num3 > 24)              //接收数据超过24，表示一帧接收完成
  152   4                      {
  153   5                          sbus_Rec_Fini_Flag = 0;   //停止接收
  154   5      
  155   5                          if (SReadBuff[0] == 0x0F && SReadBuff[24] == 0x00 && num3 == 25)    //接受完一帧数据
  156   5                          {
  157   6                              UpDate_SBUS();      //数据解析
  158   6      //                        LED_Ctrl(LED0, RVS);
  159   6                          }
  160   5                          num3 = 0;               //清空
  161   5                      }
  162   4      
  163   4                  }
  164   3              }       
  165   2              /* SBUS END*/
  166   2              COM3.RX_TimeOut = TimeOutSet3;
  167   2              }
  168   1      
  169   1              if(S3TI)
  170   1              {
  171   2                      CLR_TI3();
  172   2      
  173   2              #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
                               if(COM3.TX_send != COM3.TX_write)
                               {
                                       S3BUF = TX3_Buffer[COM3.TX_send];
                                       if(++COM3.TX_send >= COM_TX3_Lenth)             COM3.TX_send = 0;
                               }
                               else    COM3.B_TX_busy = 0;
                       #else
  181   2              COM3.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
  182   2              #endif
  183   2              }
  184   1      }
  185          #endif
  186          
  187          //========================================================================
C251 COMPILER V5.60.0,  AI8051U_UART_Isr                                                   18/11/25  13:39:14  PAGE 4   

  188          // 函数: UART4_ISR_Handler
  189          // 描述: UART4中断函数.
  190          // 参数: none.
  191          // 返回: none.
  192          // 版本: V1.0, 2020-09-23
  193          //========================================================================
  194          #ifdef UART4
  195          
  196          #include "LQ_BDGPS.h"       //北斗数据接收，简单处理 Save_Data在 LQ_BDGPS.c开头定义
  197          unsigned char GPS_buf;    //接收数据缓字符缓存
  198          unsigned char GPS_ReadBuff[128];
  199          void UART4_ISR_Handler (void) interrupt UART4_VECTOR
  200          {
  201   1              if(S4RI)
  202   1              {
  203   2              static u8 num1;
  204   2                      CLR_RI4();
  205   2      
  206   2              if(COM4.RX_Cnt >= COM_RX4_Lenth)        COM4.RX_Cnt = 0;
  207   2      //        RX4_Buffer[COM4.RX_Cnt++] = S4BUF;
  208   2              
  209   2              /* GPS_BD串口接收部分start */
  210   2      
  211   2              GPS_buf = (u8)S4BUF;
  212   2              if(GPS_buf == '\n' || GPS_buf == '\r')   //完成一帧数据接收
  213   2              {
  214   3                  strcpy((char*)Save_Data.GPS_Buffer,(const char*)GPS_ReadBuff);
  215   3                  Save_Data.isGetData=1;
  216   3                  num1 = 0;
  217   3      //            LED_Ctrl(LED1,RVS);// LED翻转闪烁
  218   3              }
  219   2              else
  220   2              {
  221   3      //            LED_Ctrl(LED0,RVS);// LED翻转闪烁
  222   3                  GPS_ReadBuff[num1++] = GPS_buf;
  223   3              }
  224   2              /* GPS_BD串口接收部分end */
  225   2              
  226   2              COM4.RX_TimeOut = TimeOutSet4;
  227   2              }
  228   1      
  229   1              if(S4TI)
  230   1              {
  231   2                      CLR_TI4();
  232   2      
  233   2              #if(UART_QUEUE_MODE == 1)   //判断是否使用队列模式
                               if(COM4.TX_send != COM4.TX_write)
                               {
                                       S4BUF = TX4_Buffer[COM4.TX_send];
                                       if(++COM4.TX_send >= COM_TX4_Lenth)             COM4.TX_send = 0;
                               }
                               else    COM4.B_TX_busy = 0;
                       #else
  241   2              COM4.B_TX_busy = 0;     //使用阻塞方式发送直接清除繁忙标志
  242   2              #endif
  243   2              }
  244   1      }
  245          #endif


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       406     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
C251 COMPILER V5.60.0,  AI8051U_UART_Isr                                                   18/11/25  13:39:14  PAGE 5   

  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       132     ------
  bit size             =         2     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
