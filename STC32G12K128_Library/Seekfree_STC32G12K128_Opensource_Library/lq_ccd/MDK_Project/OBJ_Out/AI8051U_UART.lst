C251 COMPILER V5.60.0,  AI8051U_UART                                                       18/11/25  13:45:59  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE AI8051U_UART
OBJECT MODULE PLACED IN .\OBJ_Out\AI8051U_UART.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\..\libraries\Driver\Src\AI8051U_UART.c XSMALL UNSIGNED_CHAR FLOAT64 BRO
                    -WSE INCDIR(..\..\libraries\Driver;..\..\libraries\Include;..\..\libraries\Driver\Inc;..\..\libraries\LQ_LIB\Inc;..\User)
                    - DEFINE(AI8051U_32Bit) DEBUG PRINT(.\OBJ_Out\AI8051U_UART.lst) OBJECT(.\OBJ_Out\AI8051U_UART.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* ------------------- Web: www.STCAI.com -----------------------------*/
    3          /*---------------------------------------------------------------------*/
    4          
    5          #include "AI8051U_UART.h"
    6          
    7          //========================================================================
    8          //                               ±æµÿ±‰¡ø…˘√˜
    9          //========================================================================
   10          
   11          #ifdef UART1
   12          COMx_Define     COM1;
   13          u8      UART_BUF_type TX1_Buffer[COM_TX1_Lenth];        //∑¢ÀÕª∫≥Â
   14          u8      UART_BUF_type RX1_Buffer[COM_RX1_Lenth];        //Ω” ’ª∫≥Â
   15          #endif
   16          #ifdef UART2
               COMx_Define     COM2;
               u8      UART_BUF_type TX2_Buffer[COM_TX2_Lenth];        //∑¢ÀÕª∫≥Â
               u8      UART_BUF_type RX2_Buffer[COM_RX2_Lenth];        //Ω” ’ª∫≥Â
               #endif
   21          #ifdef UART3
   22          COMx_Define     COM3;
   23          u8      UART_BUF_type TX3_Buffer[COM_TX3_Lenth];        //∑¢ÀÕª∫≥Â
   24          u8      UART_BUF_type RX3_Buffer[COM_RX3_Lenth];        //Ω” ’ª∫≥Â
   25          #endif
   26          #ifdef UART4
   27          COMx_Define     COM4;
   28          u8      UART_BUF_type TX4_Buffer[COM_TX4_Lenth];        //∑¢ÀÕª∫≥Â
   29          u8      UART_BUF_type RX4_Buffer[COM_RX4_Lenth];        //Ω” ’ª∫≥Â
   30          #endif
   31          
   32          //========================================================================
   33          // ∫Ø ˝: UART_Configuration
   34          // √Ë ˆ: UART≥ı ºªØ≥Ã–Ú.
   35          // ≤Œ ˝: UARTx: UART◊È∫≈, COMxΩ·ππ≤Œ ˝,«Î≤ŒøºUART.h¿Ôµƒ∂®“Â.
   36          // ∑µªÿ: none.
   37          // ∞Ê±æ: V1.0, 2012-10-22
   38          //========================================================================
   39          u8 UART_Configuration(u8 UARTx, COMx_InitDefine *COMx)
   40          {
   41   1      #if  defined( UART1 ) || defined( UART2 ) || defined( UART3 ) || defined( UART4 )
   42   1              u16     i;
   43   1              u32     j;
   44   1      #else
                       UARTx = NULL;
                       COMx = NULL;
               #endif
   48   1      
   49   1      #ifdef UART1
   50   1              if(UARTx == UART1)
   51   1              {
   52   2                      COM1.TX_send    = 0;
   53   2                      COM1.TX_write   = 0;
   54   2                      COM1.B_TX_busy  = 0;
   55   2                      COM1.RX_Cnt     = 0;
   56   2                      COM1.RX_TimeOut = 0;
   57   2      
C251 COMPILER V5.60.0,  AI8051U_UART                                                       18/11/25  13:45:59  PAGE 2   

   58   2                      for(i=0; i<COM_TX1_Lenth; i++)  TX1_Buffer[i] = 0;
   59   2                      for(i=0; i<COM_RX1_Lenth; i++)  RX1_Buffer[i] = 0;
   60   2      
   61   2                      SCON = (SCON & 0x3f) | COMx->UART_Mode; //ƒ£ Ω…Ë÷√
   62   2                      if((COMx->UART_Mode == UART_9bit_BRTx) || (COMx->UART_Mode == UART_8bit_BRTx))  //ø…±‰≤®Ãÿ¬ 
   63   2                      {
   64   3                              j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;      //∞¥1Tº∆À„
   65   3                              if(j >= 65536UL)        return FAIL;    //¥ÌŒÛ
   66   3                              j = 65536UL - j;
   67   3                              if(COMx->UART_BRT_Use == BRT_Timer2)
   68   3                              {
   69   4                                      T2R = 0;                //Timer stop
   70   4                                      S1BRT = 1;      //S1 BRT Use Timer2;
   71   4                                      T2_CT = 0;      //Timer2 set As Timer
   72   4                                      T2x12 = 1;      //Timer2 set as 1T mode
   73   4                                      T2H = (u8)(j>>8);
   74   4                                      T2L = (u8)j;
   75   4                                      T2R = 1;                //Timer run enable
   76   4                              }
   77   3                              else
   78   3                              {
   79   4                                      TR1 = 0;
   80   4                                      S1BRT = 0;              //S1 BRT Use Timer1;
   81   4                                      T1_CT = 0;              //Timer1 set As Timer
   82   4                                      TMOD &= ~0x30;//Timer1_16bitAutoReload;
   83   4                                      T1x12 = 1;              //Timer1 set as 1T mode
   84   4                                      TH1 = (u8)(j>>8);
   85   4                                      TL1 = (u8)j;
   86   4                                      TR1  = 1;
   87   4                              }
   88   3                      }
   89   2                      else if(COMx->UART_Mode == UART_ShiftRight)
   90   2                      {
   91   3                              if(COMx->BaudRateDouble == ENABLE)      S1M0x6 = 1;     //πÃ∂®≤®Ãÿ¬ SysClk/2
   92   3                              else                                                            S1M0x6 = 0;     //πÃ∂®≤®Ãÿ¬ SysClk/12
   93   3                      }
   94   2                      else if(COMx->UART_Mode == UART_9bit)   //πÃ∂®≤®Ãÿ¬ SysClk*2^SMOD/64
   95   2                      {
   96   3                              if(COMx->BaudRateDouble == ENABLE)      SMOD = 1;       //πÃ∂®≤®Ãÿ¬ SysClk/32
   97   3                              else                                                            SMOD = 0;       //πÃ∂®≤®Ãÿ¬ SysClk/64
   98   3                      }
   99   2                      UART1_RxEnable(COMx->UART_RxEnable);    //UARTΩ” ’ πƒ‹
  100   2      
  101   2                      return SUCCESS;
  102   2              }
  103   1      #endif
  104   1      #ifdef UART2
                       if(UARTx == UART2)
                       {
                               COM2.TX_send    = 0;
                               COM2.TX_write   = 0;
                               COM2.B_TX_busy  = 0;
                               COM2.RX_Cnt     = 0;
                               COM2.RX_TimeOut = 0;
               
                               for(i=0; i<COM_TX2_Lenth; i++)  TX2_Buffer[i] = 0;
                               for(i=0; i<COM_RX2_Lenth; i++)  RX2_Buffer[i] = 0;
               
                               S2CON = (S2CON & 0x3f) | COMx->UART_Mode;       //ƒ£ Ω…Ë÷√
                               if((COMx->UART_Mode == UART_9bit_BRTx) ||(COMx->UART_Mode == UART_8bit_BRTx))   //ø…±‰≤®Ãÿ¬ 
                               {
                                       j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;      //∞¥1Tº∆À„
                                       if(j >= 65536UL)        return FAIL;    //¥ÌŒÛ
                                       j = 65536UL - j;
                                       T2R = 0;                //Timer stop
                                       T2_CT = 0;      //Timer2 set As Timer
C251 COMPILER V5.60.0,  AI8051U_UART                                                       18/11/25  13:45:59  PAGE 3   

                                       T2x12 = 1;      //Timer2 set as 1T mode
                                       T2H = (u8)(j>>8);
                                       T2L = (u8)j;
                                       T2R = 1;                //Timer run enable
                               }
                               else    return FAIL;    //ƒ£ Ω¥ÌŒÛ
                               UART2_RxEnable(COMx->UART_RxEnable);    //UARTΩ” ’ πƒ‹
               
                               return SUCCESS;
                       }
               #endif
  135   1      #ifdef UART3
  136   1              if(UARTx == UART3)
  137   1              {
  138   2                      COM3.TX_send    = 0;
  139   2                      COM3.TX_write   = 0;
  140   2                      COM3.B_TX_busy  = 0;
  141   2                      COM3.RX_Cnt     = 0;
  142   2                      COM3.RX_TimeOut = 0;
  143   2                      for(i=0; i<COM_TX3_Lenth; i++)  TX3_Buffer[i] = 0;
  144   2                      for(i=0; i<COM_RX3_Lenth; i++)  RX3_Buffer[i] = 0;
  145   2      
  146   2                      if((COMx->UART_Mode == UART_9bit_BRTx) || (COMx->UART_Mode == UART_8bit_BRTx))  //ø…±‰≤®Ãÿ¬ 
  147   2                      {
  148   3                              if(COMx->UART_Mode == UART_9bit_BRTx)   S3_9bit();      //9bit
  149   3                              else                                                                    S3_8bit();      //8bit
  150   3                              j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;      //∞¥1Tº∆À„
  151   3                              if(j >= 65536UL)        return FAIL;    //¥ÌŒÛ
  152   3                              j = 65536UL - j;
  153   3                              if(COMx->UART_BRT_Use == BRT_Timer2)
  154   3                              {
  155   4                                      T2R = 0;                //Timer stop
  156   4                                      S3_BRT_UseTimer2();     //S3 BRT Use Timer2;
  157   4                                      T2_CT = 0;      //Timer2 set As Timer
  158   4                                      T2x12 = 1;      //Timer2 set as 1T mode
  159   4                                      T2H = (u8)(j>>8);
  160   4                                      T2L = (u8)j;
  161   4                                      T2R = 1;                //Timer run enable
  162   4                              }
  163   3                              else
  164   3                              {
  165   4                                      T3R = 0;                //Timer stop
  166   4                                      S3_BRT_UseTimer3();             //S3 BRT Use Timer3;
  167   4                                      T3H = (u8)(j>>8);
  168   4                                      T3L = (u8)j;
  169   4                                      T3_CT = 0;      //Timer3 set As Timer
  170   4                                      T3x12 = 1;      //Timer3 set as 1T mode
  171   4                                      T3R = 1;                //Timer run enable
  172   4                              }
  173   3                      }
  174   2                      else    return FAIL;    //ƒ£ Ω¥ÌŒÛ
  175   2                      UART3_RxEnable(COMx->UART_RxEnable);    //UARTΩ” ’ πƒ‹
  176   2      
  177   2                      return SUCCESS;
  178   2              }
  179   1      #endif
  180   1      #ifdef UART4
  181   1              if(UARTx == UART4)
  182   1              {
  183   2                      COM4.TX_send    = 0;
  184   2                      COM4.TX_write   = 0;
  185   2                      COM4.B_TX_busy  = 0;
  186   2                      COM4.RX_Cnt     = 0;
  187   2                      COM4.RX_TimeOut = 0;
  188   2                      for(i=0; i<COM_TX4_Lenth; i++)  TX4_Buffer[i] = 0;
  189   2                      for(i=0; i<COM_RX4_Lenth; i++)  RX4_Buffer[i] = 0;
C251 COMPILER V5.60.0,  AI8051U_UART                                                       18/11/25  13:45:59  PAGE 4   

  190   2      
  191   2                      if((COMx->UART_Mode == UART_9bit_BRTx) || (COMx->UART_Mode == UART_8bit_BRTx))  //ø…±‰≤®Ãÿ¬ 
  192   2                      {
  193   3                              if(COMx->UART_Mode == UART_9bit_BRTx)   S4_9bit();      //9bit
  194   3                              else                                                                    S4_8bit();      //8bit
  195   3                              j = (MAIN_Fosc / 4) / COMx->UART_BaudRate;      //∞¥1Tº∆À„
  196   3                              if(j >= 65536UL)        return FAIL;    //¥ÌŒÛ
  197   3                              j = 65536UL - j;
  198   3                              if(COMx->UART_BRT_Use == BRT_Timer2)
  199   3                              {
  200   4                                      T2R = 0;                //Timer stop
  201   4                                      S4_BRT_UseTimer2();     //S4 BRT Use Timer2;
  202   4                                      T2_CT = 0;      //Timer2 set As Timer
  203   4                                      T2x12 = 1;      //Timer2 set as 1T mode
  204   4                                      T2H = (u8)(j>>8);
  205   4                                      T2L = (u8)j;
  206   4                                      T2R = 1;                //Timer run enable
  207   4                              }
  208   3                              else
  209   3                              {
  210   4                                      T4R = 0;                //Timer stop
  211   4                                      S4_BRT_UseTimer4();             //S4 BRT Use Timer4;
  212   4                                      T4H = (u8)(j>>8);
  213   4                                      T4L = (u8)j;
  214   4                                      T4_CT = 0;      //Timer4 set As Timer
  215   4                                      T4x12 = 1;      //Timer4 set as 1T mode
  216   4                                      T4R = 1;                //Timer run enable
  217   4                              }
  218   3                      }
  219   2                      else    return FAIL;    //ƒ£ Ω¥ÌŒÛ
  220   2                      UART4_RxEnable(COMx->UART_RxEnable);    //UARTΩ” ’ πƒ‹
  221   2      
  222   2                      return SUCCESS;
  223   2              }
  224   1      #endif
  225   1              return FAIL;    //¥ÌŒÛ
  226   1      }
  227          
  228          /*********************************************************/
  229          
  230          /********************* UART1 ∫Ø ˝ ************************/
  231          #ifdef UART1
  232          void UART1_PutBuf(u8 dat)       //¥Æø⁄1∑¢ÀÕ∫Ø ˝
  233          {
  234   1          #if(UART_QUEUE_MODE == 1)
                       TX1_Buffer[COM1.TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â£¨ π”√∂”¡– Ω ˝æ›∑¢ÀÕ£¨“ª¥Œ–‘∑¢ÀÕ ˝æ›≥§∂»≤ª“™≥¨π˝ª∫≥Â«¯¥Û–°£
             -®COM_TXn_Lenth£©
                       if(++COM1.TX_write >= COM_TX1_Lenth)    COM1.TX_write = 0;
               
                       if(COM1.B_TX_busy == 0)         //ø’œ–
                       {
                               COM1.B_TX_busy = 1;             //±Í÷æ√¶
                               TI = 1;                                 //¥•∑¢∑¢ÀÕ÷–∂œ
                       }
                   #else
  244   1          //“‘œ¬ «◊Ë»˚∑Ω Ω∑¢ÀÕ∑Ω∑® ƒ¨»œ
  245   1              SBUF = dat;
  246   1              COM1.B_TX_busy = 1;             //±Í÷æ√¶
  247   1              while(COM1.B_TX_busy);
  248   1          #endif
  249   1      }
  250          
  251          void UART1_PutStr(u8 *puts)
  252          {
  253   1          for (; *puts != 0;  puts++)  UART1_PutBuf(*puts);   //”ˆµΩÕ£÷π∑˚0Ω· ¯
  254   1      }
C251 COMPILER V5.60.0,  AI8051U_UART                                                       18/11/25  13:45:59  PAGE 5   

  255          
  256          #endif
  257          
  258          /********************* UART2 ∫Ø ˝ ************************/
  259          #ifdef UART2
               void UART2_PutBuf(u8 dat)       //¥Æø⁄2∑¢ÀÕ∫Ø ˝
               {
                   #if(UART_QUEUE_MODE == 1)
                       TX2_Buffer[COM2.TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â£¨ π”√∂”¡– Ω ˝æ›∑¢ÀÕ£¨“ª¥Œ–‘∑¢ÀÕ ˝æ›≥§∂»≤ª“™≥¨π˝ª∫≥Â«¯¥Û–°£
             -®COM_TXn_Lenth£©
                       if(++COM2.TX_write >= COM_TX2_Lenth)    COM2.TX_write = 0;
               
                       if(COM2.B_TX_busy == 0)         //ø’œ–
                       {
                               COM2.B_TX_busy = 1;             //±Í÷æ√¶
                               S2TI = 1;                               //¥•∑¢∑¢ÀÕ÷–∂œ
                       }
                   #else
                   //“‘œ¬ «◊Ë»˚∑Ω Ω∑¢ÀÕ∑Ω∑®
                       S2BUF = dat;
                       COM2.B_TX_busy = 1;             //±Í÷æ√¶
                       while(COM2.B_TX_busy);
                   #endif
               }
               
               void UART2_PutStr(u8 *puts)
               {
                   for (; *puts != 0;  puts++)  UART2_PutBuf(*puts);   //”ˆµΩÕ£÷π∑˚0Ω· ¯
               }
               
               #endif
  285          
  286          /********************* UART3 ∫Ø ˝ ************************/
  287          #ifdef UART3
  288          void UART3_PutBuf(u8 dat)       //¥Æø⁄3∑¢ÀÕ∫Ø ˝
  289          {
  290   1          #if(UART_QUEUE_MODE == 1)
                       TX3_Buffer[COM3.TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â£¨ π”√∂”¡– Ω ˝æ›∑¢ÀÕ£¨“ª¥Œ–‘∑¢ÀÕ ˝æ›≥§∂»≤ª“™≥¨π˝ª∫≥Â«¯¥Û–°£
             -®COM_TXn_Lenth£©
                       if(++COM3.TX_write >= COM_TX3_Lenth)    COM3.TX_write = 0;
               
                       if(COM3.B_TX_busy == 0)         //ø’œ–
                       {
                               COM3.B_TX_busy = 1;             //±Í÷æ√¶
                               S3TI = 1;                               //¥•∑¢∑¢ÀÕ÷–∂œ
                       }
                   #else
  300   1          //“‘œ¬ «◊Ë»˚∑Ω Ω∑¢ÀÕ∑Ω∑®
  301   1              S3BUF = dat;
  302   1              COM3.B_TX_busy = 1;             //±Í÷æ√¶
  303   1              while(COM3.B_TX_busy);
  304   1          #endif
  305   1      }
  306          
  307          void UART3_PutStr(u8 *puts)
  308          {
  309   1          for (; *puts != 0;  puts++)  UART3_PutBuf(*puts);   //”ˆµΩÕ£÷π∑˚0Ω· ¯
  310   1      }
  311          
  312          #endif
  313          
  314          /********************* UART4 ∫Ø ˝ ************************/
  315          #ifdef UART4
  316          void UART4_PutBuf(u8 dat)       //¥Æø⁄4∑¢ÀÕ∫Ø ˝
  317          {
  318   1          #if(UART_QUEUE_MODE == 1)
C251 COMPILER V5.60.0,  AI8051U_UART                                                       18/11/25  13:45:59  PAGE 6   

                       TX4_Buffer[COM4.TX_write] = dat;        //◊∞∑¢ÀÕª∫≥Â£¨ π”√∂”¡– Ω ˝æ›∑¢ÀÕ£¨“ª¥Œ–‘∑¢ÀÕ ˝æ›≥§∂»≤ª“™≥¨π˝ª∫≥Â«¯¥Û–°£
             -®COM_TXn_Lenth£©
                       if(++COM4.TX_write >= COM_TX4_Lenth)    COM4.TX_write = 0;
               
                       if(COM4.B_TX_busy == 0)         //ø’œ–
                       {
                               COM4.B_TX_busy = 1;             //±Í÷æ√¶
                               S4TI = 1;                               //¥•∑¢∑¢ÀÕ÷–∂œ
                       }
                   #else
  328   1          //“‘œ¬ «◊Ë»˚∑Ω Ω∑¢ÀÕ∑Ω∑®
  329   1              S4BUF = dat;
  330   1              COM4.B_TX_busy = 1;             //±Í÷æ√¶
  331   1              while(COM4.B_TX_busy);
  332   1          #endif
  333   1      }
  334          
  335          void UART4_PutStr(u8 *puts)
  336          {
  337   1          for (; *puts != 0;  puts++)  UART4_PutBuf(*puts);   //”ˆµΩÕ£÷π∑˚0Ω· ¯
  338   1      }
  339          
  340          #endif
  341          
  342          
  343          
  344          /********************* Printf ∫Ø ˝ ************************/
  345          #if(PRINTF_SELECT == 1)
  346          
  347          char putchar(char c)
  348          {
  349   1              UART1_PutBuf(c);
  350   1              return c;
  351   1      }
  352          
  353          #elif(PRINTF_SELECT == 2)
               
               char putchar(char c)
               {
                       UART2_PutBuf(c);
                       return c;
               }
               
               #elif(PRINTF_SELECT == 3)
               
               char putchar(char c)
               {
                       UART3_PutBuf(c);
                       return c;
               }
               
               #elif(PRINTF_SELECT == 4)
               
               char putchar(char c)
               {
                       UART4_PutBuf(c);
                       return c;
               }
               
               #endif


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       795     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
C251 COMPILER V5.60.0,  AI8051U_UART                                                       18/11/25  13:45:59  PAGE 7   

  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       655     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
