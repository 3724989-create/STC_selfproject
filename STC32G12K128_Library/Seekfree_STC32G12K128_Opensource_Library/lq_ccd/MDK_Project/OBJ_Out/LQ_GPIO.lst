C251 COMPILER V5.60.0,  LQ_GPIO                                                            18/11/25  13:45:53  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE LQ_GPIO
OBJECT MODULE PLACED IN .\OBJ_Out\LQ_GPIO.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\..\libraries\LQ_LIB\Src\LQ_GPIO.c XSMALL UNSIGNED_CHAR FLOAT64 BROWSE I
                    -NCDIR(..\..\libraries\Driver;..\..\libraries\Include;..\..\libraries\Driver\Inc;..\..\libraries\LQ_LIB\Inc;..\User) DEFI
                    -NE(AI8051U_32Bit) DEBUG PRINT(.\OBJ_Out\LQ_GPIO.lst) OBJECT(.\OBJ_Out\LQ_GPIO.obj) 

stmt  level    source

    1          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
    2           【平    台】北京龙邱智能科技STC32位核心板
    3           【编    写】龙邱科技
    4           【E-mail  】chiusir@163.com
    5           【软件版本】V1.0 版权所有，单位使用请先联系授权
    6           【相关信息参考下列地址】
    7           【网    站】http://www.lqist.cn
    8           【淘宝店铺】http://longqiu.taobao.com
    9           --------------------------------------------------------------------------------
   10           【  IDE  】 keil C251 V5.60
   11           【Target 】 STC32G/STC8051U/AI8051U 32位模式
   12           【SYS CLK】 42 MHz使用内部晶振
   13          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   14          
   15          #include "include.h"
   16          #include "LQ_GPIO.h"
   17          
   18          /*************************************************************************
   19          *  函数名称：void GPIO_InitConfig(GPIO_Pin_e Pin_x, Port_Mode mode)
   20          *  功能说明：GPIO初始化函数
   21          *  参数说明：pin      ： 管脚标号    lq_gpio.h中定义
   22          *            mode     ： GPIO 模式   lq_gpio.h中的宏定义中选择
   23          *            output   ： 输出模式时，输出电平 1：高电平  0：低电平
   24          *  函数返回：无
   25          *  修改时间：2024年11月1日
   26          *  举    例： GPIO_InitConfig(P0_0, GPIO_OUT_PP);  //P0_0初始化推挽输出
   27          *************************************************************************/
   28          void GPIO_InitConfig(GPIO_Pin_e Pin_x, GPIO_Mode_e Mode_e)
   29          {
   30   1              u8 GPIO_Port_n, GPIO_Pin_n;
   31   1      
   32   1              GPIO_Port_n = (Pin_x&0xF0);    //Pport_num.x
   33   1              GPIO_Pin_n  = (Pin_x&0x0F);    //Px.pin_num
   34   1      
   35   1              switch(GPIO_Port_n)
   36   1              {
   37   2                      case 00:
   38   2                              if(Mode_e == OUT_IN)    {P0M1 &= ~(1<<GPIO_Pin_n);      P0M0 &= ~(1<<GPIO_Pin_n);}  //准双向口      00
   39   2                              if(Mode_e == OUT_PP)    {P0M1 &= ~(1<<GPIO_Pin_n);      P0M0 |=  (1<<GPIO_Pin_n);}  //推挽输出      01
   40   2                              if(Mode_e == HighZ_IN)  {P0M1 |=  (1<<GPIO_Pin_n);      P0M0 &= ~(1<<GPIO_Pin_n);}  //高阻态浮空    10
   41   2                              if(Mode_e == HighZ_IN)  {P0M1 |=  (1<<GPIO_Pin_n);      P0M0 |=  (1<<GPIO_Pin_n);}  //开漏输出      11
   42   2                              break;
   43   2      
   44   2                      case 10:
   45   2                              if(Mode_e == OUT_IN)    {P1M1 &= ~(1<<GPIO_Pin_n);      P1M0 &= ~(1<<GPIO_Pin_n);}
   46   2                              if(Mode_e == OUT_PP)    {P1M1 &= ~(1<<GPIO_Pin_n);      P1M0 |=  (1<<GPIO_Pin_n);}
   47   2                              if(Mode_e == HighZ_IN)  {P1M1 |=  (1<<GPIO_Pin_n);      P1M0 &= ~(1<<GPIO_Pin_n);}
   48   2                              if(Mode_e == HighZ_IN)  {P1M1 |=  (1<<GPIO_Pin_n);      P1M0 |=  (1<<GPIO_Pin_n);}
   49   2                              break;
   50   2      
   51   2                      case 20:
   52   2                              if(Mode_e == OUT_IN)    {P4M1 &= ~(1<<GPIO_Pin_n);      P4M0 &= ~(1<<GPIO_Pin_n);}
   53   2                              if(Mode_e == OUT_PP)    {P4M1 &= ~(1<<GPIO_Pin_n);      P4M0 |=  (1<<GPIO_Pin_n);}
   54   2                              if(Mode_e == HighZ_IN)  {P4M1 |=  (1<<GPIO_Pin_n);      P4M0 &= ~(1<<GPIO_Pin_n);}
   55   2                              if(Mode_e == HighZ_IN)  {P4M1 |=  (1<<GPIO_Pin_n);      P4M0 |=  (1<<GPIO_Pin_n);}
   56   2                              break;
   57   2      
C251 COMPILER V5.60.0,  LQ_GPIO                                                            18/11/25  13:45:53  PAGE 2   

   58   2                      case 30:
   59   2                              if(Mode_e == OUT_IN)    {P3M1 &= ~(1<<GPIO_Pin_n);      P3M0 &= ~(1<<GPIO_Pin_n);}
   60   2                              if(Mode_e == OUT_PP)    {P3M1 &= ~(1<<GPIO_Pin_n);      P3M0 |=  (1<<GPIO_Pin_n);}
   61   2                              if(Mode_e == HighZ_IN)  {P3M1 |=  (1<<GPIO_Pin_n);      P3M0 &= ~(1<<GPIO_Pin_n);}
   62   2                              if(Mode_e == HighZ_IN)  {P3M1 |=  (1<<GPIO_Pin_n);      P3M0 |=  (1<<GPIO_Pin_n);}
   63   2                              break;
   64   2      
   65   2                      case 4:
   66   2                              if(Mode_e == OUT_IN)    {P4M1 &= ~(1<<GPIO_Pin_n);      P4M0 &= ~(1<<GPIO_Pin_n);}
   67   2                              if(Mode_e == OUT_PP)    {P4M1 &= ~(1<<GPIO_Pin_n);      P4M0 |=  (1<<GPIO_Pin_n);}
   68   2                              if(Mode_e == HighZ_IN)  {P4M1 |=  (1<<GPIO_Pin_n);      P4M0 &= ~(1<<GPIO_Pin_n);}
   69   2                              if(Mode_e == HighZ_IN)  {P4M1 |=  (1<<GPIO_Pin_n);      P4M0 |=  (1<<GPIO_Pin_n);}
   70   2                              break;
   71   2      
   72   2                      case 50:
   73   2                              if(Mode_e == OUT_IN)    {P5M1 &= ~(1<<GPIO_Pin_n);      P5M0 &= ~(1<<GPIO_Pin_n);}
   74   2                              if(Mode_e == OUT_PP)    {P5M1 &= ~(1<<GPIO_Pin_n);      P5M0 |=  (1<<GPIO_Pin_n);}
   75   2                              if(Mode_e == HighZ_IN)  {P5M1 |=  (1<<GPIO_Pin_n);      P5M0 &= ~(1<<GPIO_Pin_n);}
   76   2                              if(Mode_e == HighZ_IN)  {P5M1 |=  (1<<GPIO_Pin_n);      P5M0 |=  (1<<GPIO_Pin_n);}
   77   2                              break;
   78   2      
   79   2                      case 60:
   80   2                              if(Mode_e == OUT_IN)    {P6M1 &= ~(1<<GPIO_Pin_n);      P6M0 &= ~(1<<GPIO_Pin_n);}
   81   2                              if(Mode_e == OUT_PP)    {P6M1 &= ~(1<<GPIO_Pin_n);      P6M0 |=  (1<<GPIO_Pin_n);}
   82   2                              if(Mode_e == HighZ_IN)  {P6M1 |=  (1<<GPIO_Pin_n);      P6M0 &= ~(1<<GPIO_Pin_n);}
   83   2                              if(Mode_e == HighZ_IN)  {P6M1 |=  (1<<GPIO_Pin_n);      P6M0 |=  (1<<GPIO_Pin_n);}
   84   2                              break;
   85   2      
   86   2                      case 70:
   87   2                              if(Mode_e == OUT_IN)    {P7M1 &= ~(1<<GPIO_Pin_n);      P7M0 &= ~(1<<GPIO_Pin_n);}
   88   2                              if(Mode_e == OUT_PP)    {P7M1 &= ~(1<<GPIO_Pin_n);      P7M0 |=  (1<<GPIO_Pin_n);}
   89   2                              if(Mode_e == HighZ_IN)  {P7M1 |=  (1<<GPIO_Pin_n);      P7M0 &= ~(1<<GPIO_Pin_n);}
   90   2                              if(Mode_e == HighZ_IN)  {P7M1 |=  (1<<GPIO_Pin_n);      P7M0 |=  (1<<GPIO_Pin_n);}
   91   2                              break;
   92   2              }
   93   1      
   94   1      }
   95          
   96          
   97          /*************************************************************************
   98          *  函数名称：void GPIO_WritePin(GPIO_Pin_e Pin_x, bit sta)
   99          *  功能说明：GPIO状态写
  100          *  参数说明：pin   ： 管脚标号    lq_gpio.h中定义
  101          *           sta   ： 1：高电平  0：低电平
  102          *  函数返回：无
  103          *  修改时间：2025年01月03日
  104          *  举    GPIO_WritePin(P0_0, SET);  //P0_0设置为高电平
  105          *************************************************************************/
  106          void GPIO_WritePin(GPIO_Pin_e Pin_x, bit sta)
  107          {
  108   1              switch(Pin_x&0xF0)
  109   1              {
  110   2                      case P0_0:(sta == SET)?(P0|=(1<<(Pin_x&0x0F))):(P0&=~(1<<(Pin_x&0x0F))); break;
  111   2                      case P1_0:(sta == SET)?(P1|=(1<<(Pin_x&0x0F))):(P1&=~(1<<(Pin_x&0x0F))); break;
  112   2                      case P2_0:(sta == SET)?(P2|=(1<<(Pin_x&0x0F))):(P2&=~(1<<(Pin_x&0x0F))); break;
  113   2                      case P3_0:(sta == SET)?(P3|=(1<<(Pin_x&0x0F))):(P3&=~(1<<(Pin_x&0x0F))); break;
  114   2                      case P4_0:(sta == SET)?(P4|=(1<<(Pin_x&0x0F))):(P4&=~(1<<(Pin_x&0x0F))); break;
  115   2                      case P5_0:(sta == SET)?(P5|=(1<<(Pin_x&0x0F))):(P5&=~(1<<(Pin_x&0x0F))); break;
  116   2                      case P6_0:(sta == SET)?(P6|=(1<<(Pin_x&0x0F))):(P6&=~(1<<(Pin_x&0x0F))); break;
  117   2                      case P7_0:(sta == SET)?(P7|=(1<<(Pin_x&0x0F))):(P7&=~(1<<(Pin_x&0x0F))); break;
  118   2              }
  119   1      }
  120          /*************************************************************************
  121          *  函数名称：bit GPIO_ReadPin(GPIO_Pin_e Pin_x)
  122          *  功能说明：GPIO状态读
  123          *  参数说明：pin   ： 管脚标号    lq_gpio.h中定义
C251 COMPILER V5.60.0,  LQ_GPIO                                                            18/11/25  13:45:53  PAGE 3   

  124          *          
  125          *  函数返回：1：高电平  0：低电平
  126          *  修改时间：2025年01月03日
  127          *  调用示例： GPIO_ReadPin(P0_0);  //读取P0_0管脚的电平
  128          *************************************************************************/
  129          bit GPIO_ReadPin(GPIO_Pin_e Pin_x)
  130          {
  131   1              switch(Pin_x&0xF0)
  132   1              {
  133   2                      case P0_0: return (P0&(1<<(Pin_x&0x0F)))?1:0;
  134   2                      case P1_0: return (P1&(1<<(Pin_x&0x0F)))?1:0;
  135   2                      case P2_0: return (P2&(1<<(Pin_x&0x0F)))?1:0;
  136   2                      case P3_0: return (P3&(1<<(Pin_x&0x0F)))?1:0;
  137   2                      case P4_0: return (P4&(1<<(Pin_x&0x0F)))?1:0;
  138   2                      case P5_0: return (P5&(1<<(Pin_x&0x0F)))?1:0;
  139   2                      case P6_0: return (P6&(1<<(Pin_x&0x0F)))?1:0;
  140   2                      case P7_0: return (P7&(1<<(Pin_x&0x0F)))?1:0;
  141   2              }
  142   1              return 0;               //若一直返回0，可能管脚出现问题
  143   1      }
  144          
  145          
  146          
  147          u8 GPIO_Read_Pin(u8 GPIO_PinS)
  148          {
  149   1          return GPIO_PinS;
  150   1      }
  151          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1899     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------          1
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
