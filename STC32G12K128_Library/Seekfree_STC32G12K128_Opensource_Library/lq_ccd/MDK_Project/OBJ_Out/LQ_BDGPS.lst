C251 COMPILER V5.60.0,  LQ_BDGPS                                                           18/11/25  13:45:54  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE LQ_BDGPS
OBJECT MODULE PLACED IN .\OBJ_Out\LQ_BDGPS.obj
COMPILER INVOKED BY: D:\MDK\C251\BIN\C251.EXE ..\..\libraries\LQ_LIB\Src\LQ_BDGPS.c XSMALL UNSIGNED_CHAR FLOAT64 BROWSE 
                    -INCDIR(..\..\libraries\Driver;..\..\libraries\Include;..\..\libraries\Driver\Inc;..\..\libraries\LQ_LIB\Inc;..\User) DEF
                    -INE(AI8051U_32Bit) DEBUG PRINT(.\OBJ_Out\LQ_BDGPS.lst) OBJECT(.\OBJ_Out\LQ_BDGPS.obj) 

stmt  level    source

    1          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
    2           „ÄêÂπ≥    Âè∞„ÄëÂåó‰∫¨ÈæôÈÇ±Êô∫ËÉΩÁßëÊäÄSTC32‰ΩçÊ†∏ÂøÉÊùø
    3           „ÄêÁºñ    ÂÜô„ÄëÈæôÈÇ±ÁßëÊäÄ
    4           „ÄêE-mail  „Äëchiusir@163.com
    5           „ÄêËΩØ‰ª∂ÁâàÊú¨„ÄëV1.0 ÁâàÊùÉÊâÄÊúâÔºåÂçï‰Ωç‰ΩøÁî®ËØ∑ÂÖàËÅîÁ≥ªÊéàÊùÉ
    6           „ÄêÁõ∏ÂÖ≥‰ø°ÊÅØÂèÇËÄÉ‰∏ãÂàóÂú∞ÂùÄ„Äë
    7           „ÄêÁΩë    Á´ô„Äëhttp://www.lqist.cn
    8           „ÄêÊ∑òÂÆùÂ∫óÈì∫„Äëhttp://longqiu.taobao.com
    9           --------------------------------------------------------------------------------
   10           „Äê  IDE  „Äë keil C251 V5.60
   11           „ÄêTarget „Äë STC32G/STC8051U/AI8051U 32‰ΩçÊ®°Âºè
   12           „ÄêSYS CLK„Äë 42 MHz‰ΩøÁî®ÂÜÖÈÉ®Êô∂ÊåØ
   13          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   14          #include "LQ_BDGPS.h"
   15          
   16          #include "include.h"
   17          
   18          
   19          Position_t point_p;
   20          
   21          _SaveData Save_Data;   //Âú®‰∏≤Âè£‰∏≠Êñ≠‰∏≠Êé•Êî∂Êï∞ÊçÆ
   22          
   23          
   24          
   25          double my_strtod(const char *str)
   26          {
   27   1        double result = 0.0;
   28   1        double fraction = 1.0;
   29   1      //  int sign = 1;
   30   1      //  int exponent = 0;
   31   1      //  int exp_sign = 1;
   32   1      //  int exp_num = 0;
   33   1      
   34   1        signed char sign = 1;
   35   1        signed char exponent = 0;
   36   1        signed char exp_sign = 1;
   37   1        signed char exp_num = 0;
   38   1          
   39   1        while (isspace(*str)) str++;  // Ë∑≥ËøáÁ©∫ÁôΩÂ≠óÁ¨¶
   40   1      
   41   1        // Â§ÑÁêÜÊ≠£Ë¥üÂè∑
   42   1        if (*str == '-' || *str == '+')
   43   1        {
   44   2          sign = (*str++ == '-' ? -1 : 1);
   45   2        }
   46   1      
   47   1        // Ëß£ÊûêÊï¥Êï∞ÈÉ®ÂàÜ
   48   1        while (isdigit(*str))
   49   1        {
   50   2          result = result * 10 + (*str++ - '0');
   51   2        }
   52   1      
   53   1        // Â§ÑÁêÜÂ∞èÊï∞ÁÇπ
   54   1        if (*str == '.')
   55   1        {
   56   2          str++;
   57   2          while (isdigit(*str))
C251 COMPILER V5.60.0,  LQ_BDGPS                                                           18/11/25  13:45:54  PAGE 2   

   58   2          {
   59   3            fraction /= 10;
   60   3            result += (*str++ - '0') * fraction;
   61   3          }
   62   2        }
   63   1      
   64   1        // Â§ÑÁêÜÊåáÊï∞ÈÉ®ÂàÜ
   65   1        if (*str == 'e' || *str == 'E')
   66   1        {
   67   2          str++;
   68   2          // Â§ÑÁêÜÊåáÊï∞ÁöÑÊ≠£Ë¥üÂè∑
   69   2          if (*str == '-' || *str == '+')
   70   2          {
   71   3            exp_sign = (*str++ == '-' ? -1 : 1);
   72   3          }
   73   2          exp_num = 0;
   74   2          while (isdigit(*str))
   75   2          {
   76   3            exp_num = exp_num * 10 + (*str++ - '0');
   77   3          }
   78   2          exponent = exp_sign * exp_num;
   79   2        }
   80   1      
   81   1        while (exponent > 0)
   82   1        {
   83   2          result *= 10;
   84   2          exponent--;
   85   2        }
   86   1        while (exponent < 0)
   87   1        {
   88   2          result /= 10;
   89   2          exponent++;
   90   2        }
   91   1      
   92   1        return sign * result;
   93   1      }
   94          
   95           
   96           
   97          
   98          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
   99          @ÂáΩÊï∞ÂêçÁß∞Ôºövoid parseGpsBuffer(void);
  100          @ÂäüËÉΩËØ¥ÊòéÔºöÊï∞ÊçÆËß£Êûê
  101          @ÂèÇÊï∞ËØ¥ÊòéÔºöÊó†
  102          @ÂáΩÊï∞ËøîÂõûÔºöÊó†
  103          @‰øÆÊîπÊó∂Èó¥Ôºö2022/02/24
  104          @Â§á    Ê≥®ÔºöÂ∞Ü‰∏≤Âè£Êî∂Âà∞ÁöÑÊï∞ÊçÆÂàÜÈó®Âà´Á±ªÁöÑ‰øùÂ≠òÂà∞ÁªìÊûÑ‰Ωì‰∏≠
  105          @           $GNRMC,130416.000,A,2236.91843,N,11359.19128,E,0.001,306.28,090720,,,A*4F
  106          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
  107          void parseGpsBuffer(void)
  108          {
  109   1        char *subString;
  110   1        char *subStringNext;
  111   1        char i = 0;
  112   1        if (Save_Data.isGetData)      //Â¶ÇÊûúÂ≠óÁ¨¶‰∏≤‰∏ç‰∏∫Á©∫
  113   1        {
  114   2          for (i = 0 ; i <= 8 ; i++)  //Âæ™ÁéØ7Ê¨°
  115   2          {
  116   3            if (i == 0)
  117   3            {
  118   4              if ((subString = strchr(Save_Data.GPS_Buffer, ',')) == NULL)  //Ê≤°ÊúâÊ£ÄÊµãÂà∞ÈÄóÂè∑
  119   4                while(1);             //Ëß£ÊûêÈîôËØØ
  120   4            }
  121   3            else  //Ê£ÄÊµãÂà∞ÈÄóÂè∑ÔºåËøîÂõûÈÄóÂè∑ÁöÑ‰ΩçÁΩÆ
  122   3            {
  123   4              subString++;    //‰ΩçÁΩÆÂä†1ÔºàÂÆö‰ΩçÂà∞ÈÄóÂè∑ÁöÑÂêé‰∏Ä‰ΩçÔºâ
C251 COMPILER V5.60.0,  LQ_BDGPS                                                           18/11/25  13:45:54  PAGE 3   

  124   4              if ((subStringNext = strchr(subString, ',')) != NULL)//ÂÆö‰Ωç‰∏ã‰∏Ä‰∏™ÈÄóÂè∑ÁöÑ‰ΩçÁΩÆ
  125   4              {
  126   5                char usefullBuffer[2];
  127   5                switch(i)
  128   5                {
  129   6                case 1:
  130   6                    memcpy(Save_Data.UTCTime, subString, subStringNext - subString);       //‰∏§‰∏™ÈÄóÂè∑‰πãÈó¥
             -‰∏∫ Êó∂Èó¥‰ø°ÊÅØ Âπ∂ËΩ¨Êç¢ÊàêÂåó‰∫¨Êó∂Èó¥
  131   6                    Save_Data.UTCTime[1] = Save_Data.UTCTime[1]+ 8;
  132   6                    if(Save_Data.UTCTime[1] > '9')
  133   6                    {
  134   7                      Save_Data.UTCTime[0]++;
  135   7                      if(Save_Data.UTCTime[0] == '3')
  136   7                        Save_Data.UTCTime[0] = '0';
  137   7                      Save_Data.UTCTime[1] = (Save_Data.UTCTime[1] % '9') + '0'-1;
  138   7                    }
  139   6                    break;//ÁªìÊùüswitch
  140   6                case 2:memcpy(usefullBuffer,            subString, subStringNext - subString);break; //Êï∞ÊçÆÊò
             -ØÂê¶ÊúâÊïàÊ†áÂøó
  141   6                case 3:memcpy(Save_Data.latitude,       subString, subStringNext - subString);break;  //Ëé∑ÂèñÁ
             -∫¨Â∫¶‰ø°ÊÅØ
  142   6                case 4:memcpy(Save_Data.N_S,            subString, subStringNext - subString);break;  //Ëé∑ÂèñN
             -/S
  143   6                case 5:memcpy(Save_Data.longitude,      subString, subStringNext - subString);break;  //Ëé∑ÂèñÁ
             -ªèÂ∫¶‰ø°ÊÅØ
  144   6                case 6:memcpy(Save_Data.E_W,            subString, subStringNext - subString);break;  //Ëé∑ÂèñE
             -/W
  145   6                case 7:memcpy(Save_Data.speed,          subString, subStringNext - subString);break;  //Ëé∑ÂèñÈ
             -ÄüÂ∫¶
  146   6                case 8:memcpy(Save_Data.direction,      subString, subStringNext - subString);break;  //Ëé∑ÂèñÊ
             -ñπÂêë
  147   6                default:break;
  148   6                }
  149   5                subString = subStringNext;    //‰∏ã‰∏Ä‰∏™ÈÄóÂè∑‰ΩçÁΩÆÁªôÁ¨¨‰∏Ä‰∏™ÊåáÈíàÔºå
  150   5                Save_Data.isParseData = 1; //ÊâãÂä®ÁªôÁúüÂÄºÔºåÔºàÊï∞ÊçÆÊòØÂê¶Ëß£ÊûêÂÆåÊàêÔºâ
  151   5                //          if(usefullBuffer[0] == 'A')
  152   5                //            Save_Data.isUsefull = true;
  153   5                //          else if(usefullBuffer[0] == 'V')
  154   5                //            Save_Data.isUsefull = false;
  155   5              }
  156   4              else
  157   4              {
  158   5      //          while(1); //Ëß£ÊûêÈîôËØØ
  159   5                 UART1_PutStr("ÂåóÊñóÊï∞ÊçÆËß£ÊûêÈîôËØØ\n");
  160   5              }
  161   4            }
  162   3          }
  163   2        }
  164   1      }
  165          
  166          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  167          @ÂáΩÊï∞ÂêçÁß∞Ôºöchar Get_IntData(int* Lon_Z, int* Lon_X, int* Lat_Z, int* Lat_X);
  168          @ÂäüËÉΩËØ¥ÊòéÔºöÁªèÁ∫¨Â∫¶ÂéüÂßãÂÄº
  169          @ÂèÇÊï∞ËØ¥ÊòéÔºöLon_ZÔºàÁªèÂ∫¶Êï¥Êï∞ÔºâÔºåLon_XÔºàÁªèÂ∫¶Â∞èÊï∞ÔºâÔºåLat_ZÔºàÁ∫¨Â∫¶Êï¥Êï∞Ôºâ,Lat_XÔºàÁ∫¨Â∫
             -¶Â∞èÊï∞Ôºâ
  170          @ÂáΩÊï∞ËøîÂõûÔºöÊó†
  171          @‰øÆÊîπÊó∂Èó¥Ôºö2022/02/24
  172          @Â§á    Ê≥®ÔºöÂ∞ÜÁªìÊûÑ‰Ωì‰∏≠ÁöÑÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢ÊàêÊï∞ÊçÆÔºåÊúâ‰∏§ÁßçÊñπÂºèÔºå#if 1Ôºö‰ª•Â∞èÊï∞ÁÇπ‰∏∫ÂàÜÁï
             -å„ÄÇ#if 0ÔºöËá™Â∑±ÊâãÂä®Ë∞ÉËäÇ
  173          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
  174          char Get_IntData(int* Lon_Z, int* Lon_X, int* Lat_Z, int* Lat_X)
  175          {
  176   1      #if 1
  177   1        //Âà§Êñ≠Á∫¨Â∫¶ÂÄº‰∏≠ÊòØÂê¶Êúâ‚Äò.'Êúâ:ËØ¥ÊòéÊúâÊï∞ÊçÆ ‰æãÂ¶ÇÔºö3946.99715  ÂèòÂåñËåÉÂõ¥Âú®ÂêéÂÖ≠‰Ωç‰∏≠Â
             -èòÂåñÔºåÊúÄÂêé‰∏Ä‰Ωç‰∏çÁ®≥ÂÆöÂèØËàçÂéª„ÄÇÂèñÂÄº‰∏∫3946Âíå99715
  178   1        if((strstr(Save_Data.latitude, ".")) != NULL)
C251 COMPILER V5.60.0,  LQ_BDGPS                                                           18/11/25  13:45:54  PAGE 4   

  179   1        {
  180   2          sscanf(Save_Data.latitude, "%d.%d",&(* Lat_Z), &(* Lat_X));
  181   2        }
  182   1        else
  183   1          return 0;
  184   1        //ÁªèÂ∫¶ÂéüÁêÜÂêå‰∏ä ‰æãÂ¶ÇÔºö11628.32198  ÂèñÂÄº‰∏∫11628 Âíå 32198
  185   1        if((strstr(Save_Data.longitude, ".")) != NULL)
  186   1        {
  187   2          sscanf(Save_Data.longitude, "%d.%d",&(* Lon_Z), &(* Lon_X));
  188   2        }
  189   1        else
  190   1          return 0;
  191   1        return 1;
  192   1      #else
                 unsigned num=0;
                 //Âà§Êñ≠Á∫¨Â∫¶ÂÄº‰∏≠ÊòØÂê¶Êúâ‚Äò.'Êúâ:ËØ¥ÊòéÊúâÊï∞ÊçÆ ‰æãÂ¶ÇÔºö3946.99715  ÂèòÂåñËåÉÂõ¥Âú®ÂêéÂÖ≠‰Ωç‰∏≠Â
             -èòÂåñÔºåÊúÄÂêé‰∏Ä‰Ωç‰∏çÁ®≥ÂÆöÂèØËàçÂéª„ÄÇ
                 if((strstr(Save_Data.latitude, ".")) != NULL)
                 {
                   *Lat_Z = (Save_Data.latitude[0] - '0')*100 + (Save_Data.latitude[1] - '0')*10 + (Save_Data.latitude[2
             -] - '0');
                   num    = (Save_Data.latitude[3] - '0')*100000 + (Save_Data.latitude[5] - '0')*10000 + (Save_Data.lati
             -tude[6] - '0')*1000 + \
                            (Save_Data.latitude[7] - '0')*100 + (Save_Data.latitude[8] - '0')*10 + (Save_Data.latitude[9
             -] - '0');
                   *Lat_X = num;       //ÂèñÂÄº‰∏∫394 Âíå 699715
                 }
                 else
                   return 0;
                 //ÁªèÂ∫¶ÂéüÁêÜÂêå‰∏ä ‰æãÂ¶ÇÔºö11628.32198
                 if((strstr(Save_Data.longitude, ".")) != NULL)
                 {
                   *Lon_Z = (Save_Data.longitude[0] - '0')*1000 + (Save_Data.longitude[1] - '0')*100 + \
                            (Save_Data.longitude[2] - '0')*10 + (Save_Data.longitude[3] - '0');
                   num    = (Save_Data.longitude[4] - '0')*100000 + (Save_Data.longitude[6] - '0')*10000 + (Save_Data.lo
             -ngitude[7] - '0')*1000 + \
                            (Save_Data.longitude[8] - '0')*100 + (Save_Data.longitude[9] - '0')*10 + (Save_Data.longitud
             -e[10] - '0');
                   *Lon_X = num;       //ÂèñÂÄº‰∏∫1162 Âíå 832198
                 }
                 else
                   return 0;
                 return 1;
               #endif
  217   1      }
  218          
  219          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  220          @ÂáΩÊï∞ÂêçÁß∞Ôºöchar Get_DoubleData(double* Lon, double* Lat)
  221          @ÂäüËÉΩËØ¥ÊòéÔºöÁªèÁ∫¨Â∫¶Â≠óÁ¨¶‰∏≤ËΩ¨ÂåñÊàêÊµÆÁÇπÊï∞
  222          @ÂèÇÊï∞ËØ¥ÊòéÔºöLonÔºàÁªèÂ∫¶ÔºâÔºåLatÔºàÁ∫¨Â∫¶Ôºâ
  223          @ÂáΩÊï∞ËøîÂõûÔºö0:ËΩ¨ÂåñÂ§±Ë¥• 1ÔºöËΩ¨ÂåñÊàêÂäü
  224          @‰øÆÊîπÊó∂Èó¥Ôºö2022/02/24
  225          @Â§á    Ê≥®Ôºö
  226          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
  227          char Get_DoubleData(_SaveData * BDdata, double *Lon ,double *Lat)
  228          {
  229   1          double gW,gJ;
  230   1          gJ = my_strtod(BDdata->longitude);
  231   1          gW = my_strtod(BDdata->latitude);
  232   1          if(gW == 0.0)
  233   1              return 0;
  234   1          else
  235   1              *Lon = gJ/100.0;
  236   1          if(gJ == 0.0)
  237   1              return 0;
  238   1          else
C251 COMPILER V5.60.0,  LQ_BDGPS                                                           18/11/25  13:45:54  PAGE 5   

  239   1              *Lat = gW/100.0;
  240   1          return 1;
  241   1      }
  242          
  243          void Test_BD_GPS(void)
  244          {
  245   1          char txt[32];
  246   1          double Lon=0.0, Lat=0.0, tim=0.0;
  247   1      
  248   1          OLED_Init();
  249   1          OLED_CLS();
  250   1          UART_Init(UART4,115200ul);     //Êé•Êî∂ÂåóÊñóÊ®°ÂùóÂùêÊ†á
  251   1      
  252   1          sprintf(txt, "BD Test");
  253   1          OLED_P6x8Str(0, 0,"BD Test"); // Â∞Ütxt‰∏≠ ÂÜÖÂÆπÊòæÁ§∫Âá∫Êù•
  254   1          UART4_PutStr("USER Init OK from UART4 \r\n");
  255   1          while(1)
  256   1          {
  257   2      //        parseGpsBuffer();
  258   2              if (Save_Data.isGetData)      //Â¶ÇÊûúÂ≠óÁ¨¶‰∏≤‰∏ç‰∏∫Á©∫  isGetDataÂú®‰∏≤Âè£Êé•Êî∂‰∏≠Êñ≠‰∏≠ÁΩÆ‰Ωç
  259   2              {
  260   3                  if(EOF != sscanf(Save_Data.GPS_Buffer, "$BDRMC,%lf,A,%lf,N,%lf,E,", &tim, &Lat, &Lon))  //std
             -io.h ->  EOF = -1
  261   3                  {
  262   4                      OLED_P6x8Str(0, 1, "Parsing BeiDou"); 
  263   4                  }else if(EOF != sscanf(Save_Data.GPS_Buffer, "$GNRMC,%lf,A,%lf,N,%lf,E,", &tim, &Lat, &Lon))
  264   3                  {
  265   4                      OLED_P6x8Str(0, 1, "Parsing GPS   ");
  266   4                  }else{
  267   4                      OLED_P6x8Str(0, 1, "Parsing error ");
  268   4                  }
  269   3      
  270   3              }
  271   2      
  272   2              OLED_P6x8Str(0, 1,"Type:double");
  273   2              sprintf(txt, "T:%f",tim);               //Êó∂Èó¥
  274   2              OLED_P6x8Str(0, 2, txt);  UART1_PutStr(txt);
  275   2              sprintf(txt, "N:%f",Lat/100);           //ËΩ¨ÂåñÊàêÊï∞ÊçÆ
  276   2              OLED_P6x8Str(0, 3, txt);  UART1_PutStr(txt);
  277   2              sprintf(txt, "E:%f",Lon/100);
  278   2              OLED_P6x8Str(0, 4, txt);  UART1_PutStr(txt);
  279   2              LED_Ctrl(LED0,RVS);// LEDÁøªËΩ¨Èó™ÁÉÅ
  280   2              
  281   2              delay_ms(50);
  282   2          }
  283   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1557     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       205        119
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       193     ------
End of Module Information.

C251 COMPILER V5.60.0,  LQ_BDGPS                                                           18/11/25  13:45:54  PAGE 6   


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
